<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>BlockArena 3D</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      font-family: system-ui, sans-serif;
      color: #fff;
    }
    #hud {
      position: fixed;
      top: 12px;
      left: 12px;
      z-index: 10;
      font-size: 13px;
      pointer-events: none;
      text-shadow: 0 0 4px #000;
    }
    #hp-bar-wrapper {
      width: 180px;
      height: 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.08);
      overflow: hidden;
      margin-bottom: 4px;
    }
    #hp-bar {
      height: 100%;
      width: 100%;
      background: linear-gradient(90deg, #00ff88, #00c4ff);
      transition: width 0.1s linear;
    }
    #hud-line {
      opacity: 0.8;
    }
    #leaderboard {
      position: fixed;
      top: 12px;
      right: 12px;
      z-index: 10;
      font-size: 13px;
      text-align: right;
      pointer-events: none;
      text-shadow: 0 0 4px #000;
    }
    #leaderboard-title {
      font-weight: 600;
      margin-bottom: 4px;
      opacity: 0.9;
    }
    #lb-entries div {
      opacity: 0.85;
    }
    #center-dot {
      position: fixed;
      top: 50%;
      left: 50%;
      width: 4px;
      height: 4px;
      margin-left: -2px;
      margin-top: -2px;
      background: #fff;
      border-radius: 50%;
      pointer-events: none;
      z-index: 10;
      box-shadow: 0 0 6px #000;
    }
    #killfeed {
      position: fixed;
      bottom: 12px;
      right: 12px;
      z-index: 10;
      font-size: 12px;
      text-align: right;
      pointer-events: none;
      text-shadow: 0 0 4px #000;
    }
    #killfeed div {
      margin-top: 2px;
      opacity: 0.9;
    }
    #overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 8px;
      background: rgba(0,0,0,0.85);
      z-index: 20;
    }
    #overlay input {
      padding: 6px 10px;
      font-size: 16px;
    }
    #overlay button {
      padding: 6px 14px;
      font-size: 16px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="hud">
    <div id="hp-bar-wrapper"><div id="hp-bar"></div></div>
    <div id="hud-line">
      <span id="hp-text">HP: 100</span> ·
      <span id="kd-text">K/D: 0 / 0</span> ·
      <span id="ammo-text">Rifle · ∞</span>
    </div>
  </div>

  <div id="leaderboard">
    <div id="leaderboard-title">Leaderboard</div>
    <div id="lb-entries"></div>
  </div>

  <div id="center-dot"></div>

  <div id="killfeed"></div>

  <div id="overlay">
    <h1>BlockArena 3D</h1>
    <p>Fast‑paced hitscan arena shooter. No login, just play.</p>
    <input id="name-input" placeholder="Your name" maxlength="12" />
    <button id="play-btn">Click to Play</button>
    <small>Game will capture your mouse (Pointer Lock).</small>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script>
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);

    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    const hemi = new THREE.HemisphereLight(0xffffff, 0x222222, 0.9);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(10, 20, 10);
    scene.add(dir);

    const floorGeo = new THREE.PlaneGeometry(80, 80);
    const floorMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    scene.add(floor);

    const wallMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
    const wallGeo = new THREE.BoxGeometry(80, 8, 1);
    const wall1 = new THREE.Mesh(wallGeo, wallMat);
    wall1.position.set(0, 4, -40);
    const wall2 = wall1.clone(); wall2.position.set(0, 4, 40);
    const wall3 = new THREE.Mesh(new THREE.BoxGeometry(1, 8, 80), wallMat);
    wall3.position.set(-40, 4, 0);
    const wall4 = wall3.clone(); wall4.position.set(40, 4, 0);
    scene.add(wall1, wall2, wall3, wall4);

    const boxGeo = new THREE.BoxGeometry(6, 6, 6);
    const boxMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
    const obstacles = [];
    for (let i = 0; i < 6; i++) {
      const box = new THREE.Mesh(boxGeo, boxMat);
      box.position.set(
        (Math.random() - 0.5) * 50,
        3,
        (Math.random() - 0.5) * 50
      );
      scene.add(box);
      obstacles.push(box);
    }

    const hpBar = document.getElementById('hp-bar');
    const hpText = document.getElementById('hp-text');
    const kdText = document.getElementById('kd-text');
    const ammoText = document.getElementById('ammo-text');
    const lbEntriesEl = document.getElementById('lb-entries');
    const killfeedEl = document.getElementById('killfeed');
    const overlay = document.getElementById('overlay');
    const nameInput = document.getElementById('name-input');
    const playBtn = document.getElementById('play-btn');
    nameInput.value = localStorage.getItem('ba_name') || '';

    const canvasEl = renderer.domElement;
    let pointerLocked = false;

    function requestPointerLock() {
      canvasEl.requestPointerLock = canvasEl.requestPointerLock || canvasEl.mozRequestPointerLock;
      canvasEl.requestPointerLock();
    }

    document.addEventListener('pointerlockchange', () => {
      pointerLocked = document.pointerLockElement === canvasEl;
    });

    const keys = {};
    window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; });
    window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

    let yaw = 0;
    let pitch = 0;

    document.addEventListener('mousemove', e => {
      if (!pointerLocked) return;
      const sensitivity = 0.0025;
      yaw -= e.movementX * sensitivity;
      pitch -= e.movementY * sensitivity;
      const maxPitch = Math.PI / 2 - 0.1;
      pitch = Math.max(-maxPitch, Math.min(maxPitch, pitch));
    });

    class Player {
      constructor(name, color, isBot = false) {
        this.name = name;
        this.color = color;
        this.isBot = isBot;
        this.health = 100;
        this.maxHealth = 100;
        this.kills = 0;
        this.deaths = 0;
        this.score = 0;
        this.speed = 18;
        this.botDecisionTimer = 0;
        this.target = null;
        this.shootCooldown = 0;
        this.mesh = new THREE.Mesh(
          new THREE.BoxGeometry(1, 2, 1),
          new THREE.MeshStandardMaterial({ color })
        );
        this.mesh.position.set(
          (Math.random() - 0.5) * 40,
          1,
          (Math.random() - 0.5) * 40
        );
        scene.add(this.mesh);

        const nameDiv = document.createElement('div');
        nameDiv.style.position = 'absolute';
        nameDiv.style.fontSize = '11px';
        nameDiv.style.color = '#fff';
        nameDiv.style.textShadow = '0 0 3px #000';
        nameDiv.textContent = name;
        document.body.appendChild(nameDiv);
        this.nameLabel = nameDiv;
      }

      get position() {
        return this.mesh.position;
      }

      respawn() {
        this.health = this.maxHealth;
        this.mesh.position.set(
          (Math.random() - 0.5) * 40,
          1,
          (Math.random() - 0.5) * 40
        );
      }

      update(dt) {
        if (this.isBot) this.updateBot(dt);
        this.shootCooldown -= dt;
        this.updateNameLabel();
      }

      updateNameLabel() {
        const vector = new THREE.Vector3();
        vector.copy(this.mesh.position);
        vector.y += 2.4;
        vector.project(camera);
        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
        this.nameLabel.style.left = `${x - 20}px`;
        this.nameLabel.style.top = `${y - 20}px`;
        this.nameLabel.style.display = (vector.z < 1) ? 'block' : 'none';
      }

      updateBot(dt) {
        this.botDecisionTimer -= dt;
        if (this.botDecisionTimer <= 0) {
          this.botDecisionTimer = 0.4 + Math.random() * 0.6;
          this.pickTarget();
        }
        if (!this.target) return;
        const dx = this.target.position.x - this.position.x;
        const dz = this.target.position.z - this.position.z;
        const dist = Math.hypot(dx, dz);
        const dirX = dx / (dist || 1);
        const dirZ = dz / (dist || 1);

        const moveSpeed = this.speed * (dist > 6 ? 1 : 0);
        this.tryMove(dirX, dirZ, dt, moveSpeed);

        const angle = Math.atan2(dx, dz);
        this.mesh.rotation.y = angle;

        if (dist < 35 && this.shootCooldown <= 0) {
          this.shoot(angle);
        }
      }

      pickTarget() {
        let best = null;
        let bestDist = Infinity;
        for (const p of players) {
          if (p === this) continue;
          const dx = p.position.x - this.position.x;
          const dz = p.position.z - this.position.z;
          const d = Math.hypot(dx, dz);
          if (d < bestDist) {
            bestDist = d;
            best = p;
          }
        }
        this.target = best;
      }

      tryMove(dirX, dirZ, dt, speedOverride = null) {
        const speed = speedOverride ?? this.speed;
        const nx = dirX * speed * dt;
        const nz = dirZ * speed * dt;
        const newPos = this.position.clone();
        newPos.x += nx;
        newPos.z += nz;

        if (Math.abs(newPos.x) > 38 || Math.abs(newPos.z) > 38) return;

        for (const box of obstacles) {
          const b = box.position;
          const half = 3.5;
          if (newPos.x > b.x - half && newPos.x < b.x + half &&
              newPos.z > b.z - half && newPos.z < b.z + half) {
            return;
          }
        }

        this.position.copy(newPos);
      }

      shoot(angle) {
        this.shootCooldown = 0.25;
        const origin = this.position.clone();
        origin.y += 1.2;
        const dir = new THREE.Vector3(Math.sin(angle), 0, Math.cos(angle));
        raycastShot(this, origin, dir);
      }

      destroy() {
        scene.remove(this.mesh);
        this.nameLabel.remove();
      }
    }

    const players = [];
    let localPlayer = null;

    function createPlayers(playerName) {
      players.length = 0;
      if (localPlayer) localPlayer.destroy();
      localPlayer = new Player(playerName, 0x00e0ff, false);
      players.push(localPlayer);

      const botColors = [0xff5c5c, 0xff9f1c, 0x2ec4b6, 0xe71d36, 0x9b5de5, 0xf15bb5];
      for (let i = 0; i < 7; i++) {
        const bot = new Player('Bot' + (i + 1), botColors[i % botColors.length], true);
        players.push(bot);
      }

      setupWeapon();
    }

    const raycaster = new THREE.Raycaster();

    const tracers = [];
    const damageTexts = [];

    function addTracer(start, end) {
      const material = new THREE.LineBasicMaterial({ color: 0xffffaa });
      const points = [start.clone(), end.clone()];
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const line = new THREE.Line(geometry, material);
      scene.add(line);
      tracers.push({ line, life: 0.06 });
    }

    function addDamageText(worldPos, amount) {
      const div = document.createElement('div');
      div.style.position = 'absolute';
      div.style.fontSize = '12px';
      div.style.color = '#ffeb3b';
      div.style.fontWeight = '600';
      div.style.textShadow = '0 0 4px #000';
      div.textContent = '-' + amount;
      document.body.appendChild(div);
      damageTexts.push({
        el: div,
        pos: worldPos.clone(),
        life: 0.6,
        vy: 0.8
      });
    }

    function addKillfeed(killer, victim) {
      const div = document.createElement('div');
      div.textContent = `${killer.name} → ${victim.name}`;
      killfeedEl.prepend(div);
      setTimeout(() => div.remove(), 4000);
    }

    function raycastShot(shooter, origin, dir) {
      const maxDist = 80;
      raycaster.set(origin, dir);
      const meshes = players
        .filter(p => p !== shooter && p.health > 0)
        .map(p => p.mesh);
      const hits = raycaster.intersectObjects(meshes, false);
      let hitPoint = origin.clone().add(dir.clone().multiplyScalar(maxDist));
      if (hits.length > 0 && hits[0].distance <= maxDist) {
        const hitMesh = hits[0].object;
        hitPoint = hits[0].point.clone();
        const victim = players.find(p => p.mesh === hitMesh);
        if (victim) {
          const dmg = 35;
          victim.health -= dmg;
          addDamageText(hitPoint, dmg);
          if (victim.health <= 0) {
            shooter.kills++;
            shooter.score += 10;
            victim.deaths++;
            addKillfeed(shooter, victim);
            victim.respawn();
          }
        }
      }
      addTracer(origin, hitPoint);
      triggerMuzzleFlash();
    }

    let weaponGroup = null;
    let muzzleFlash = null;
    let muzzleFlashTimer = 0;

    function setupWeapon() {
      if (weaponGroup) {
        camera.remove(weaponGroup);
      }
      weaponGroup = new THREE.Group();

      const bodyGeo = new THREE.BoxGeometry(0.2, 0.2, 0.7);
      const bodyMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.3, roughness: 0.4 });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.set(0.3, -0.25, -0.6);
      weaponGroup.add(body);

      const barrelGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.5, 8);
      const barrelMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
      const barrel = new THREE.Mesh(barrelGeo, barrelMat);
      barrel.rotation.z = Math.PI / 2;
      barrel.position.set(0.45, -0.25, -0.6);
      weaponGroup.add(barrel);

      const flashGeo = new THREE.ConeGeometry(0.12, 0.3, 8);
      const flashMat = new THREE.MeshBasicMaterial({ color: 0xfff3a3 });
      muzzleFlash = new THREE.Mesh(flashGeo, flashMat);
      muzzleFlash.rotation.z = Math.PI / 2;
      muzzleFlash.position.set(0.7, -0.25, -0.6);
      muzzleFlash.visible = false;
      weaponGroup.add(muzzleFlash);

      camera.add(weaponGroup);
      scene.add(camera);
    }

    function triggerMuzzleFlash() {
      if (!muzzleFlash) return;
      muzzleFlash.visible = true;
      muzzleFlashTimer = 0.05;
    }

    let lastTime = 0;
    let mouseShoot = false;

    document.addEventListener('mousedown', e => {
      if (!pointerLocked) return;
      if (e.button === 0) mouseShoot = true;
    });
    document.addEventListener('mouseup', e => {
      if (e.button === 0) mouseShoot = false;
    });

    function update(dt) {
      if (!localPlayer) return;

      let moveX = 0, moveZ = 0;
      if (keys['w']) moveZ -= 1;
      if (keys['s']) moveZ += 1;
      if (keys['a']) moveX -= 1;
      if (keys['d']) moveX += 1;

      const len = Math.hypot(moveX, moveZ) || 1;
      moveX /= len;
      moveZ /= len;

      const forward = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
      const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 1, 0)).negate();

      const dir = new THREE.Vector3();
      dir.addScaledVector(forward, moveZ);
      dir.addScaledVector(right, moveX);

      if (dir.lengthSq() > 0) {
        dir.normalize();
        localPlayer.tryMove(dir.x, dir.z, dt);
      }

      const camOffset = new THREE.Vector3(0, 3, 0);
      camera.position.copy(localPlayer.position).add(camOffset);
      camera.rotation.set(0, 0, 0);
      camera.rotateY(yaw);
      camera.rotateX(pitch);

      for (const p of players) p.update(dt);

      if (mouseShoot && localPlayer.shootCooldown <= 0) {
        const origin = localPlayer.position.clone();
        origin.y += 1.2;
        const dirVec = new THREE.Vector3(0, 0, -1);
        dirVec.applyEuler(camera.rotation);
        raycastShot(localPlayer, origin, dirVec);
        localPlayer.shootCooldown = 0.12;
      }

      if (muzzleFlash) {
        muzzleFlashTimer -= dt;
        if (muzzleFlashTimer <= 0) muzzleFlash.visible = false;
      }

      for (let i = tracers.length - 1; i >= 0; i--) {
        tracers[i].life -= dt;
        if (tracers[i].life <= 0) {
          scene.remove(tracers[i].line);
          tracers.splice(i, 1);
        }
      }

      for (let i = damageTexts.length - 1; i >= 0; i--) {
        const d = damageTexts[i];
        d.life -= dt;
        d.pos.y += d.vy * dt;
        const v = d.pos.clone().project(camera);
        const x = (v.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-v.y * 0.5 + 0.5) * window.innerHeight;
        d.el.style.left = `${x}px`;
        d.el.style.top = `${y}px`;
        d.el.style.opacity = (d.life / 0.6).toFixed(2);
        if (d.life <= 0) {
          d.el.remove();
          damageTexts.splice(i, 1);
        }
      }

      updateHUD();
    }

    function updateHUD() {
      hpText.textContent = `HP: ${Math.max(0, localPlayer.health | 0)}`;
      const hpRatio = Math.max(0, localPlayer.health / localPlayer.maxHealth);
      hpBar.style.width = `${hpRatio * 100}%`;
      kdText.textContent = `K/D: ${localPlayer.kills} / ${localPlayer.deaths}`;
      ammoText.textContent = 'Rifle · ∞';

      const sorted = [...players].sort((a, b) => b.score - a.score).slice(0, 5);
      lbEntriesEl.innerHTML = '';
      sorted.forEach((p, i) => {
        const div = document.createElement('div');
        const me = p === localPlayer ? ' (you)' : '';
        div.textContent = `${i + 1}. ${p.name}${me} — ${p.score}`;
        lbEntriesEl.appendChild(div);
      });
    }

    function loop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
      lastTime = timestamp;

      update(dt);
      renderer.render(scene, camera);
      requestAnimationFrame(loop);
    }

    requestAnimationFrame(loop);

    playBtn.onclick = () => {
      const name = (nameInput.value.trim() || 'Guest').slice(0, 12);
      localStorage.setItem('ba_name', name);
      overlay.style.display = 'none';
      createPlayers(name);
      requestPointerLock();
    };
  </script>
</body>
</html>
