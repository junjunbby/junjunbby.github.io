<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>DashDome.io (Single File)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #111;
      overflow: hidden;
      font-family: system-ui, sans-serif;
      color: #fff;
    }
    #ui {
      position: fixed;
      top: 8px;
      left: 8px;
      z-index: 10;
      font-size: 14px;
      pointer-events: none;
    }
    #leaderboard {
      position: fixed;
      top: 8px;
      right: 8px;
      z-index: 10;
      font-size: 14px;
      text-align: right;
      pointer-events: none;
    }
    #name-input-wrapper {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.8);
      z-index: 20;
      flex-direction: column;
      gap: 8px;
    }
    #name-input-wrapper input {
      padding: 6px 10px;
      font-size: 16px;
    }
    #name-input-wrapper button {
      padding: 6px 14px;
      font-size: 16px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div id="ui">
    <div id="stats">Power: 1 | Kills: 0 | Deaths: 0</div>
    <div>Move: WASD / Arrows — Dash: Space</div>
  </div>

  <div id="leaderboard">
    <div><strong>Leaderboard</strong></div>
    <div id="lb-entries"></div>
  </div>

  <div id="name-input-wrapper">
    <h1>DashDome.io</h1>
    <p>Enter a name and jump in instantly.</p>
    <input id="player-name" placeholder="Your name" maxlength="12" />
    <button id="play-btn">Play</button>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let width = window.innerWidth;
    let height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    window.addEventListener('resize', () => {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
    });

    const keys = {};
    window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; });
    window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

    const statsEl = document.getElementById('stats');
    const lbEntriesEl = document.getElementById('lb-entries');
    const nameWrapper = document.getElementById('name-input-wrapper');
    const nameInput = document.getElementById('player-name');
    const playBtn = document.getElementById('play-btn');

    nameInput.value = localStorage.getItem('dd_name') || '';

    let playerName = 'You';

    playBtn.onclick = () => {
      playerName = (nameInput.value.trim() || 'Guest').slice(0, 12);
      localStorage.setItem('dd_name', playerName);
      nameWrapper.style.display = 'none';
      resetGame();
    };

    class Entity {
      constructor(x, y, radius, color) {
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.radius = radius;
        this.color = color;
      }
      update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
      }
      draw() {
        ctx.beginPath();
        ctx.fillStyle = this.color;
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    class Player extends Entity {
      constructor(x, y, name, color, isBot = false) {
        super(x, y, 14, color);
        this.name = name;
        this.isBot = isBot;
        this.baseSpeed = 220;
        this.power = 1;
        this.maxPower = 12;
        this.health = 100;
        this.maxHealth = 100;
        this.score = 0;
        this.kills = 0;
        this.deaths = 0;
        this.isDashing = false;
        this.dashCooldown = 1.4;
        this.dashTimer = 0;
        this.dashDuration = 0.12;
        this.dashTimeLeft = 0;
        this.lastHitBy = null;
        this.target = null;
        this.botDecisionTimer = 0;
      }

      radiusWithPower() {
        return this.radius + this.power * 0.8;
      }

      update(dt) {
        if (this.isBot) this.botAI(dt);

        if (!this.isDashing) {
          this.x += this.vx * dt;
          this.y += this.vy * dt;
        } else {
          this.x += this.vx * dt;
          this.y += this.vy * dt;
          this.dashTimeLeft -= dt;
          if (this.dashTimeLeft <= 0) {
            this.isDashing = false;
          }
        }

        this.dashTimer -= dt;
        this.x = Math.max(40, Math.min(width - 40, this.x));
        this.y = Math.max(40, Math.min(height - 40, this.y));
      }

      draw() {
        const r = this.radiusWithPower();
        ctx.beginPath();
        ctx.fillStyle = this.color;
        ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#ffffff';
        ctx.stroke();

        // health bar
        const hw = r * 1.4;
        const hh = 4;
        const hx = this.x - hw / 2;
        const hy = this.y - r - 14;
        ctx.fillStyle = '#000000aa';
        ctx.fillRect(hx, hy, hw, hh);
        const ratio = this.health / this.maxHealth;
        ctx.fillStyle = '#00ff88';
        ctx.fillRect(hx, hy, hw * ratio, hh);

        // name
        ctx.fillStyle = '#ffffff';
        ctx.font = '12px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText(this.name, this.x, hy - 4);
      }

      tryDash(dirX, dirY) {
        if (this.dashTimer > 0 || (dirX === 0 && dirY === 0)) return;
        this.isDashing = true;
        this.dashTimer = this.dashCooldown;
        this.dashTimeLeft = this.dashDuration;
        const len = Math.hypot(dirX, dirY) || 1;
        const nx = dirX / len;
        const ny = dirY / len;
        const dashSpeed = 520 + this.power * 12;
        this.vx = nx * dashSpeed;
        this.vy = ny * dashSpeed;
      }

      botAI(dt) {
        this.botDecisionTimer -= dt;
        if (this.botDecisionTimer <= 0) {
          this.botDecisionTimer = 0.4 + Math.random() * 0.6;
          this.pickTarget();
        }

        let dirX = 0, dirY = 0;
        if (this.target) {
          const dx = this.target.x - this.x;
          const dy = this.target.y - this.y;
          const dist = Math.hypot(dx, dy);
          if (dist > 10) {
            dirX = dx / dist;
            dirY = dy / dist;
          }
          if (dist < 220 && this.dashTimer <= 0) {
            this.tryDash(dirX, dirY);
          }
        }

        if (!this.isDashing) {
          const speed = this.baseSpeed + this.power * 6;
          this.vx = dirX * speed;
          this.vy = dirY * speed;
        }
      }

      pickTarget() {
        let best = null;
        let bestDist = Infinity;
        for (const p of players) {
          if (p === this) continue;
          const dx = p.x - this.x;
          const dy = p.y - this.y;
          const d = Math.hypot(dx, dy);
          if (d < bestDist) {
            bestDist = d;
            best = p;
          }
        }
        this.target = best;
      }
    }

    class Orb extends Entity {
      constructor(x, y) {
        super(x, y, 5, '#ffcc00');
      }
    }

    class Hazard {
      constructor(x, y, w, h, phaseOffset = 0) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.phaseOffset = phaseOffset;
      }
      isActive(time) {
        const t = (time + this.phaseOffset) % 4;
        return t > 1.5 && t < 3.2;
      }
      draw(time) {
        const active = this.isActive(time);
        ctx.fillStyle = active ? 'rgba(255,60,60,0.6)' : 'rgba(255,60,60,0.25)';
        ctx.fillRect(this.x - this.w / 2, this.y - this.h / 2, this.w, this.h);
      }
    }

    let players = [];
    let orbs = [];
    let hazards = [];
    let localPlayer = null;
    let lastTime = 0;

    function resetGame() {
      players = [];
      orbs = [];
      hazards = [];

      localPlayer = new Player(width / 2, height / 2, playerName, '#00e0ff', false);
      players.push(localPlayer);

      const botColors = ['#ff5c5c', '#ff9f1c', '#2ec4b6', '#e71d36', '#9b5de5', '#f15bb5'];
      for (let i = 0; i < 7; i++) {
        const x = 80 + Math.random() * (width - 160);
        const y = 80 + Math.random() * (height - 160);
        const bot = new Player(x, y, 'Bot' + (i + 1), botColors[i % botColors.length], true);
        players.push(bot);
      }

      for (let i = 0; i < 60; i++) spawnOrb();

      hazards.push(new Hazard(width / 2, height / 2, 220, 120, 0));
      hazards.push(new Hazard(width / 3, height / 3, 140, 80, 1.3));
      hazards.push(new Hazard((2 * width) / 3, (2 * height) / 3, 140, 80, 2.1));
    }

    function spawnOrb() {
      const x = 60 + Math.random() * (width - 120);
      const y = 60 + Math.random() * (height - 120);
      orbs.push(new Orb(x, y));
    }

    function handleInput(dt) {
      if (!localPlayer) return;
      let dirX = 0, dirY = 0;
      if (keys['w'] || keys['arrowup']) dirY -= 1;
      if (keys['s'] || keys['arrowdown']) dirY += 1;
      if (keys['a'] || keys['arrowleft']) dirX -= 1;
      if (keys['d'] || keys['arrowright']) dirX += 1;

      const len = Math.hypot(dirX, dirY) || 1;
      dirX /= len;
      dirY /= len;

      if (!localPlayer.isDashing) {
        const speed = localPlayer.baseSpeed + localPlayer.power * 6;
        localPlayer.vx = dirX * speed;
        localPlayer.vy = dirY * speed;
      }

      if (keys[' '] && !localPlayer.isDashing && localPlayer.dashTimer <= 0) {
        localPlayer.tryDash(dirX, dirY);
      }
    }

    function circleCollide(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      const r = (a.radiusWithPower ? a.radiusWithPower() : a.radius) +
                (b.radiusWithPower ? b.radiusWithPower() : b.radius);
      return dx * dx + dy * dy <= r * r;
    }

    function update(dt, time) {
      handleInput(dt);

      for (const p of players) p.update(dt);

      // orbs
      for (let i = orbs.length - 1; i >= 0; i--) {
        const orb = orbs[i];
        for (const p of players) {
          const dx = p.x - orb.x;
          const dy = p.y - orb.y;
          const r = (p.radiusWithPower ? p.radiusWithPower() : p.radius) + orb.radius;
          if (dx * dx + dy * dy <= r * r) {
            p.power = Math.min(p.maxPower, p.power + 1);
            if (!p.isBot && p === localPlayer) {
              localPlayer.score += 1;
            }
            orbs.splice(i, 1);
            spawnOrb();
            break;
          }
        }
      }

      // hazards
      for (const h of hazards) {
        const active = h.isActive(time);
        if (!active) continue;
        for (const p of players) {
          if (p.health <= 0) continue;
          if (p.x > h.x - h.w / 2 && p.x < h.x + h.w / 2 &&
              p.y > h.y - h.h / 2 && p.y < h.y + h.h / 2) {
            p.health -= 25 * dt;
            if (p.health <= 0) {
              p.deaths++;
              if (p === localPlayer) {
                respawn(p);
              } else {
                respawn(p);
              }
            }
          }
        }
      }

      // dash combat
      for (let i = 0; i < players.length; i++) {
        const a = players[i];
        if (!a.isDashing) continue;
        for (let j = 0; j < players.length; j++) {
          if (i === j) continue;
          const b = players[j];
          if (b.health <= 0) continue;
          if (circleCollide(a, b)) {
            const dmg = 40 + a.power * 6;
            b.health -= dmg * dt * 10;
            b.lastHitBy = a;
            if (b.health <= 0) {
              a.kills++;
              a.score += 10 + b.power;
              b.deaths++;
              respawn(b);
            }
          }
        }
      }

      updateStats();
      updateLeaderboard();
    }

    function respawn(p) {
      p.health = p.maxHealth;
      p.power = 1;
      p.x = 80 + Math.random() * (width - 160);
      p.y = 80 + Math.random() * (height - 160);
      p.vx = 0;
      p.vy = 0;
      p.isDashing = false;
      p.dashTimer = 0.8;
    }

    function updateStats() {
      if (!localPlayer) return;
      statsEl.textContent =
        `Power: ${localPlayer.power} | Kills: ${localPlayer.kills} | Deaths: ${localPlayer.deaths}`;
    }

    function updateLeaderboard() {
      const sorted = [...players].sort((a, b) => b.score - a.score).slice(0, 5);
      lbEntriesEl.innerHTML = '';
      sorted.forEach((p, i) => {
        const div = document.createElement('div');
        const me = p === localPlayer ? ' (you)' : '';
        div.textContent = `${i + 1}. ${p.name}${me} — ${p.score}`;
        lbEntriesEl.appendChild(div);
      });
    }

    function draw(time) {
      ctx.clearRect(0, 0, width, height);

      // arena bounds
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 4;
      ctx.strokeRect(40, 40, width - 80, height - 80);

      for (const h of hazards) h.draw(time);

      for (const o of orbs) o.draw();
      for (const p of players) p.draw();
    }

    function loop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
      lastTime = timestamp;

      if (localPlayer) {
        update(dt, timestamp / 1000);
        draw(timestamp / 1000);
      } else {
        ctx.clearRect(0, 0, width, height);
      }

      requestAnimationFrame(loop);
    }

    requestAnimationFrame(loop);
  </script>
</body>
</html>
