<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Mini-Maze 2D Neon Arcade</title>
<style>
body { margin:0; background:#111; font-family:sans-serif; overflow:hidden; }
canvas { display:block; margin:0 auto; background: radial-gradient(circle at center, #111 0%, #000 100%); transition: transform 0.05s ease; }
#ui {
  position:absolute; top:10px; left:10px; color:white;
  background: rgba(0,0,0,0.5); padding:10px; border-radius:6px;
  font-family:sans-serif; font-weight:bold; text-shadow:0 0 5px #0ff;
}
</style>
</head>
<body>
<div id="ui">
<p id="status">Level: 1 | Score: 0 | Time: 30 | Highscore: 0</p>
</div>
<canvas id="gameCanvas" width="500" height="500"></canvas>

<!-- Sounds -->
<audio id="starSound" src="https://freesound.org/data/previews/320/320655_5260876-lq.mp3"></audio>
<audio id="trapSound" src="https://freesound.org/data/previews/198/198841_2859976-lq.mp3"></audio>
<audio id="levelUpSound" src="https://freesound.org/data/previews/146/146725_2615114-lq.mp3"></audio>

<script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/gsap.min.js"></script>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let tileSize = 40;

let gridSize = 5, level=1, score=0, timer=30;
let highscore = localStorage.getItem('miniMazeHighscore')||0;

let mazeMap=[], player={x:0,y:0,px:0,py:0}, exit={x:4,y:4};
let stars=[], traps=[], particles=[];
let touchStart=null;
let showLevelIntro = true;
let levelIntroAlpha = 1;

generateMaze();
draw();
updateStatus();
startTimer();

window.addEventListener('keydown', handleKey);
window.addEventListener('touchstart', e=>{ touchStart = e.touches[0]; });
window.addEventListener('touchend', handleSwipe);

function playSound(id){ const audio=document.getElementById(id); if(audio){ audio.currentTime=0; audio.play(); } }

function generateMaze(){
    mazeMap = Array(gridSize).fill(0).map(()=>Array(gridSize).fill(0));
    stars=[]; traps=[];
    for(let y=0;y<gridSize;y++){
        for(let x=0;x<gridSize;x++){
            if(x===0 && y===0){ mazeMap[y][x]=0; continue; }
            if(x===gridSize-1 && y===gridSize-1){ mazeMap[y][x]=4; exit={x,y}; continue; }
            const r=Math.random();
            if(r<0.2){ mazeMap[y][x]=1; }
            else if(r<0.3){ mazeMap[y][x]=2; stars.push({x,y}); }
            else if(r<0.35){ mazeMap[y][x]=3; traps.push({x,y}); }
        }
    }
    player={x:0,y:0,px:0,py:0};
    showLevelIntroAnimation();
}

function handleKey(e){
    if(showLevelIntro) return; // disable movement during intro
    let dx=0,dy=0;
    if(e.key==='ArrowUp'||e.key==='w') dy=-1;
    else if(e.key==='ArrowDown'||e.key==='s') dy=1;
    else if(e.key==='ArrowLeft'||e.key==='a') dx=-1;
    else if(e.key==='ArrowRight'||e.key==='d') dx=1;
    movePlayer(dx,dy);
}

function handleSwipe(e){
    if(showLevelIntro) return;
    if(!touchStart) return;
    const touchEnd = e.changedTouches[0];
    const dx = touchEnd.clientX - touchStart.clientX;
    const dy = touchEnd.clientY - touchStart.clientY;
    if(Math.abs(dx)>Math.abs(dy)) dx>0?movePlayer(1,0):movePlayer(-1,0);
    else dy>0?movePlayer(0,1):movePlayer(0,-1);
    touchStart=null;
}

function canMove(x,y){ return x>=0 && y>=0 && x<gridSize && y<gridSize && mazeMap[y][x]!==1; }

function movePlayer(dx,dy){
    const nx = player.x+dx, ny = player.y+dy;
    if(!canMove(nx,ny)) return;
    player.x=nx; player.y=ny;
    const targetX = nx*tileSize+5, targetY = ny*tileSize+5;
    gsap.to(player, {px: targetX, py: targetY, duration:0.15, ease:"power1.out"});

    // collect star
    for(let i=stars.length-1;i>=0;i--){
        if(stars[i].x===nx && stars[i].y===ny){
            playSound('starSound');
            spawnParticles(nx,ny,"#0ff");
            stars.splice(i,1);
            score+=10;
        }
    }

    // trap
    traps.forEach(t=>{
        if(t.x===nx && t.y===ny){
            timer = Math.max(1,timer-5);
            playSound('trapSound');
            shakeCanvas();
            spawnParticles(nx,ny,"#f0f");
        }
    });

    // exit
    if(nx===exit.x && ny===exit.y){
        playSound('levelUpSound');
        spawnParticles(nx,ny,"#0f0");
        level++; gridSize=Math.min(gridSize+1,10); timer=30;
        generateMaze();
    }

    updateStatus();
}

function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // walls glow
    for(let y=0;y<gridSize;y++){
        for(let x=0;x<gridSize;x++){
            if(mazeMap[y][x]===1){
                ctx.shadowColor="#0ff";
                ctx.shadowBlur=12;
                ctx.fillStyle="#00f";
                ctx.fillRect(x*tileSize,y*tileSize,tileSize,tileSize);
            }
        }
    }
    ctx.shadowBlur=0;

    // stars glow
    stars.forEach(s=>{
        ctx.shadowColor="#0ff";
        ctx.shadowBlur=15;
        ctx.fillStyle="#0ff";
        ctx.fillRect(s.x*tileSize+10,s.y*tileSize+10,20,20);
    });
    ctx.shadowBlur=0;

    // traps glow
    traps.forEach(t=>{
        ctx.shadowColor="#f0f";
        ctx.shadowBlur=15;
        ctx.fillStyle="#f0f";
        ctx.fillRect(t.x*tileSize+10,t.y*tileSize+10,20,20);
    });
    ctx.shadowBlur=0;

    // exit glow
    ctx.shadowColor="#0f0";
    ctx.shadowBlur=20;
    ctx.fillStyle="#0f0";
    ctx.fillRect(exit.x*tileSize+5,exit.y*tileSize+5,30,30);
    ctx.shadowBlur=0;

    // player glow
    ctx.shadowColor="#ff0";
    ctx.shadowBlur=15;
    ctx.fillStyle="#ff0";
    ctx.fillRect(player.px, player.py,30,30);
    ctx.shadowBlur=0;

    // particles
    for(let i=particles.length-1;i>=0;i--){
        const p = particles[i];
        ctx.fillStyle=p.color;
        ctx.globalAlpha = p.life/15;
        ctx.fillRect(p.x*tileSize+20 + p.vx, p.y*tileSize+20 + p.vy, p.size, p.size);
        p.vx += (Math.random()-0.5)*0.5;
        p.vy -= Math.random()*0.5;
        p.life--;
        if(p.life<=0) particles.splice(i,1);
    }
    ctx.globalAlpha=1;

    // level intro
    if(showLevelIntro){
        ctx.save();
        ctx.globalAlpha = levelIntroAlpha;
        ctx.fillStyle = "#0ff";
        ctx.font = "bold 60px Arial";
        ctx.textAlign = "center";
        ctx.shadowColor="#0ff";
        ctx.shadowBlur=20;
        ctx.fillText("LEVEL " + level, canvas.width/2, canvas.height/2);
        ctx.restore();
    }

    requestAnimationFrame(draw);
}

function spawnParticles(x,y,color){
    for(let i=0;i<15;i++){
        particles.push({x:x,y:y,size:2+Math.random()*3,color:color,life:10+Math.random()*10,vx:0,vy:0});
    }
}

function shakeCanvas(){
    const intensity=5;
    const dx=(Math.random()-0.5)*intensity;
    const dy=(Math.random()-0.5)*intensity;
    canvas.style.transform=`translate(${dx}px,${dy}px)`;
    setTimeout(()=>{ canvas.style.transform="translate(0,0)"; },50);
}

function updateStatus(){
    if(score>highscore){ highscore=score; localStorage.setItem('miniMazeHighscore',highscore); }
    document.getElementById('status').textContent = `Level: ${level} | Score: ${score} | Time: ${timer} | Highscore: ${highscore}`;
}

function startTimer(){
    setInterval(()=>{
        timer--;
        if(timer<=0){ alert('Time up!'); score=0; timer=30; level=1; gridSize=5; generateMaze(); }
        updateStatus();
    },1000);
}

function showLevelIntroAnimation(){
    showLevelIntro = true;
    levelIntroAlpha = 1;
    gsap.to(window, {duration:1.2, levelIntroAlpha:0, onUpdate:()=>{}, onComplete:()=>{showLevelIntro=false;}});
}
</script>
</body>
</html>
