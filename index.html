<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>BlockArena 3D</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      font-family: system-ui, sans-serif;
      color: #fff;
    }
    #hud {
      position: fixed;
      top: 8px;
      left: 8px;
      z-index: 10;
      font-size: 14px;
      pointer-events: none;
      text-shadow: 0 0 4px #000;
    }
    #leaderboard {
      position: fixed;
      top: 8px;
      right: 8px;
      z-index: 10;
      font-size: 14px;
      text-align: right;
      pointer-events: none;
      text-shadow: 0 0 4px #000;
    }
    #center-dot {
      position: fixed;
      top: 50%;
      left: 50%;
      width: 4px;
      height: 4px;
      margin-left: -2px;
      margin-top: -2px;
      background: #fff;
      border-radius: 50%;
      pointer-events: none;
      z-index: 10;
    }
    #overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 8px;
      background: rgba(0,0,0,0.85);
      z-index: 20;
    }
    #overlay input {
      padding: 6px 10px;
      font-size: 16px;
    }
    #overlay button {
      padding: 6px 14px;
      font-size: 16px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="hud">
    <div id="stats">HP: 100 | Kills: 0 | Deaths: 0</div>
    <div>WASD to move, mouse to aim, click to shoot</div>
  </div>
  <div id="leaderboard">
    <div><strong>Leaderboard</strong></div>
    <div id="lb-entries"></div>
  </div>
  <div id="center-dot"></div>

  <div id="overlay">
    <h1>BlockArena 3D</h1>
    <p>Fast‑paced FPS arena. No login, just play.</p>
    <input id="name-input" placeholder="Your name" maxlength="12" />
    <button id="play-btn">Click to Play</button>
    <small>Game will capture your mouse (Pointer Lock).</small>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script>
    // basic three.js setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // lights
    const hemi = new THREE.HemisphereLight(0xffffff, 0x222222, 0.9);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(10, 20, 10);
    scene.add(dir);

    // arena floor + walls
    const floorGeo = new THREE.PlaneGeometry(80, 80);
    const floorMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    scene.add(floor);

    const wallMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
    const wallGeo = new THREE.BoxGeometry(80, 8, 1);
    const wall1 = new THREE.Mesh(wallGeo, wallMat);
    wall1.position.set(0, 4, -40);
    const wall2 = wall1.clone(); wall2.position.set(0, 4, 40);
    const wall3 = new THREE.Mesh(new THREE.BoxGeometry(1, 8, 80), wallMat);
    wall3.position.set(-40, 4, 0);
    const wall4 = wall3.clone(); wall4.position.set(40, 4, 0);
    scene.add(wall1, wall2, wall3, wall4);

    // some obstacles
    const boxGeo = new THREE.BoxGeometry(6, 6, 6);
    const boxMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
    const obstacles = [];
    for (let i = 0; i < 6; i++) {
      const box = new THREE.Mesh(boxGeo, boxMat);
      box.position.set(
        (Math.random() - 0.5) * 50,
        3,
        (Math.random() - 0.5) * 50
      );
      scene.add(box);
      obstacles.push(box);
    }

    // HUD
    const statsEl = document.getElementById('stats');
    const lbEntriesEl = document.getElementById('lb-entries');
    const overlay = document.getElementById('overlay');
    const nameInput = document.getElementById('name-input');
    const playBtn = document.getElementById('play-btn');
    nameInput.value = localStorage.getItem('ba_name') || '';

    // pointer lock
    let pointerLocked = false;
    const canvasEl = renderer.domElement;

    function requestPointerLock() {
      canvasEl.requestPointerLock = canvasEl.requestPointerLock || canvasEl.mozRequestPointerLock;
      canvasEl.requestPointerLock();
    }

    document.addEventListener('pointerlockchange', () => {
      pointerLocked = document.pointerLockElement === canvasEl;
    });

    // input
    const keys = {};
    window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; });
    window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

    let yaw = 0;
    let pitch = 0;

    document.addEventListener('mousemove', e => {
      if (!pointerLocked) return;
      const sensitivity = 0.0025;
      yaw -= e.movementX * sensitivity;
      pitch -= e.movementY * sensitivity;
      const maxPitch = Math.PI / 2 - 0.1;
      pitch = Math.max(-maxPitch, Math.min(maxPitch, pitch));
    });

    // entities
    class Player {
      constructor(name, color, isBot = false) {
        this.name = name;
        this.color = color;
        this.isBot = isBot;
        this.health = 100;
        this.maxHealth = 100;
        this.kills = 0;
        this.deaths = 0;
        this.score = 0;
        this.speed = 18;
        this.botDecisionTimer = 0;
        this.target = null;
        this.shootCooldown = 0;
        this.mesh = new THREE.Mesh(
          new THREE.BoxGeometry(1, 2, 1),
          new THREE.MeshStandardMaterial({ color })
        );
        this.mesh.position.set(
          (Math.random() - 0.5) * 40,
          1,
          (Math.random() - 0.5) * 40
        );
        scene.add(this.mesh);

        const nameDiv = document.createElement('div');
        nameDiv.style.position = 'absolute';
        nameDiv.style.fontSize = '11px';
        nameDiv.style.color = '#fff';
        nameDiv.style.textShadow = '0 0 3px #000';
        nameDiv.textContent = name;
        document.body.appendChild(nameDiv);
        this.nameLabel = nameDiv;
      }

      get position() {
        return this.mesh.position;
      }

      respawn() {
        this.health = this.maxHealth;
        this.mesh.position.set(
          (Math.random() - 0.5) * 40,
          1,
          (Math.random() - 0.5) * 40
        );
      }

      update(dt) {
        if (this.isBot) this.updateBot(dt);
        this.shootCooldown -= dt;
        this.updateNameLabel();
      }

      updateNameLabel() {
        const vector = new THREE.Vector3();
        vector.copy(this.mesh.position);
        vector.y += 2.4;
        vector.project(camera);
        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
        this.nameLabel.style.left = `${x - 20}px`;
        this.nameLabel.style.top = `${y - 20}px`;
        this.nameLabel.style.display = (vector.z < 1) ? 'block' : 'none';
      }

      updateBot(dt) {
        this.botDecisionTimer -= dt;
        if (this.botDecisionTimer <= 0) {
          this.botDecisionTimer = 0.4 + Math.random() * 0.6;
          this.pickTarget();
        }
        if (!this.target) return;
        const dx = this.target.position.x - this.position.x;
        const dz = this.target.position.z - this.position.z;
        const dist = Math.hypot(dx, dz);
        const dirX = dx / (dist || 1);
        const dirZ = dz / (dist || 1);

        const moveSpeed = this.speed * (dist > 6 ? 1 : 0);
        this.tryMove(dirX, dirZ, dt, moveSpeed);

        const angle = Math.atan2(dx, dz);
        this.mesh.rotation.y = angle;

        if (dist < 35 && this.shootCooldown <= 0) {
          this.shoot(angle);
        }
      }

      pickTarget() {
        let best = null;
        let bestDist = Infinity;
        for (const p of players) {
          if (p === this) continue;
          const dx = p.position.x - this.position.x;
          const dz = p.position.z - this.position.z;
          const d = Math.hypot(dx, dz);
          if (d < bestDist) {
            bestDist = d;
            best = p;
          }
        }
        this.target = best;
      }

      tryMove(dirX, dirZ, dt, speedOverride = null) {
        const speed = speedOverride ?? this.speed;
        const nx = dirX * speed * dt;
        const nz = dirZ * speed * dt;
        const newPos = this.position.clone();
        newPos.x += nx;
        newPos.z += nz;

        if (Math.abs(newPos.x) > 38 || Math.abs(newPos.z) > 38) return;

        for (const box of obstacles) {
          const b = box.position;
          const half = 3.5;
          if (newPos.x > b.x - half && newPos.x < b.x + half &&
              newPos.z > b.z - half && newPos.z < b.z + half) {
            return;
          }
        }

        this.position.copy(newPos);
      }

      shoot(angle) {
        this.shootCooldown = 0.5;
        const origin = this.position.clone();
        origin.y += 1.2;
        const dir = new THREE.Vector3(Math.sin(angle), 0, Math.cos(angle));
        raycastShot(this, origin, dir);
      }

      destroy() {
        scene.remove(this.mesh);
        this.nameLabel.remove();
      }
    }

    const players = [];
    let localPlayer = null;

    function createPlayers(playerName) {
      players.length = 0;
      if (localPlayer) localPlayer.destroy();
      localPlayer = new Player(playerName, 0x00e0ff, false);
      players.push(localPlayer);

      const botColors = [0xff5c5c, 0xff9f1c, 0x2ec4b6, 0xe71d36, 0x9b5de5, 0xf15bb5];
      for (let i = 0; i < 7; i++) {
        const bot = new Player('Bot' + (i + 1), botColors[i % botColors.length], true);
        players.push(bot);
      }
    }

    // shooting / raycast
    const raycaster = new THREE.Raycaster();

    function raycastShot(shooter, origin, dir) {
      const maxDist = 80;
      raycaster.set(origin, dir);
      const meshes = players
        .filter(p => p !== shooter && p.health > 0)
        .map(p => p.mesh);
      const hits = raycaster.intersectObjects(meshes, false);
      if (hits.length > 0 && hits[0].distance <= maxDist) {
        const hitMesh = hits[0].object;
        const victim = players.find(p => p.mesh === hitMesh);
        if (!victim) return;
        const dmg = 40;
        victim.health -= dmg;
        if (victim.health <= 0) {
          shooter.kills++;
          shooter.score += 10;
          victim.deaths++;
          victim.respawn();
        }
      }
    }

    // game loop
    let lastTime = 0;

    function update(dt) {
      if (!localPlayer) return;

      // local movement
      let moveX = 0, moveZ = 0;
      if (keys['w']) moveZ -= 1;
      if (keys['s']) moveZ += 1;
      if (keys['a']) moveX -= 1;
      if (keys['d']) moveX += 1;

      const len = Math.hypot(moveX, moveZ) || 1;
      moveX /= len;
      moveZ /= len;

      const forward = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
      const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 1, 0)).negate();

      const dir = new THREE.Vector3();
      dir.addScaledVector(forward, moveZ);
      dir.addScaledVector(right, moveX);

      if (dir.lengthSq() > 0) {
        dir.normalize();
        localPlayer.tryMove(dir.x, dir.z, dt);
      }

      // camera follow
      const camOffset = new THREE.Vector3(0, 3, 0);
      camera.position.copy(localPlayer.position).add(camOffset);
      camera.rotation.set(0, 0, 0);
      camera.rotateY(yaw);
      camera.rotateX(pitch);

      // bots + cooldowns
      for (const p of players) p.update(dt);

      // shooting input
      if (mouseShoot && localPlayer.shootCooldown <= 0) {
        const origin = localPlayer.position.clone();
        origin.y += 1.2;
        const dirVec = new THREE.Vector3(0, 0, -1);
        dirVec.applyEuler(camera.rotation);
        raycastShot(localPlayer, origin, dirVec);
        localPlayer.shootCooldown = 0.25;
      }

      updateHUD();
    }

    function updateHUD() {
      statsEl.textContent =
        `HP: ${Math.max(0, localPlayer.health | 0)} | Kills: ${localPlayer.kills} | Deaths: ${localPlayer.deaths}`;

      const sorted = [...players].sort((a, b) => b.score - a.score).slice(0, 5);
      lbEntriesEl.innerHTML = '';
      sorted.forEach((p, i) => {
        const div = document.createElement('div');
        const me = p === localPlayer ? ' (you)' : '';
        div.textContent = `${i + 1}. ${p.name}${me} — ${p.score}`;
        lbEntriesEl.appendChild(div);
      });
    }

    let mouseShoot = false;
    document.addEventListener('mousedown', e => {
      if (!pointerLocked) return;
      if (e.button === 0) mouseShoot = true;
    });
    document.addEventListener('mouseup', e => {
      if (e.button === 0) mouseShoot = false;
    });

    function loop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
      lastTime = timestamp;

      update(dt);
      renderer.render(scene, camera);
      requestAnimationFrame(loop);
    }

    requestAnimationFrame(loop);

    // start flow
    playBtn.onclick = () => {
      const name = (nameInput.value.trim() || 'Guest').slice(0, 12);
      localStorage.setItem('ba_name', name);
      overlay.style.display = 'none';
      createPlayers(name);
      requestPointerLock();
    };
  </script>
</body>
</html>
