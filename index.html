<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Mini-Maze 2.5D Arcade</title>
<style>
body { margin:0; overflow:hidden; font-family:sans-serif; background:#222; }
#ui { position:absolute; top:10px; left:10px; background:rgba(255,255,255,0.85); padding:10px; border-radius:8px; z-index:10; }
#ui h3 { margin:0 0 5px 0; color:#333; }
#ui p { margin:2px 0; color:#222; }
</style>
</head>
<body>
<div id="ui">
<h3>Mini-Maze 2.5D Arcade</h3>
<p>Arrow keys / WASD / swipe: move</p>
<p id="status">Level: 1 | Score: 0 | Time: 30 | Highscore: 0</p>
</div>

<!-- Audio -->
<audio id="starSound" src="https://freesound.org/data/previews/320/320655_5260876-lq.mp3"></audio>
<audio id="trapSound" src="https://freesound.org/data/previews/198/198841_2859976-lq.mp3"></audio>
<audio id="levelUpSound" src="https://freesound.org/data/previews/146/146725_2615114-lq.mp3"></audio>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/gsap.min.js"></script>

<script>
let scene, camera, renderer;
let gridSize=5, cellSize=4, level=1, score=0, timer=30;
let highscore = localStorage.getItem('miniMazeHighscore')||0;
let mazeMap=[], playerPos={x:0,y:0}, exitPos={x:0,y:0};
let playerMesh;
let stars=[], traps=[], particlesGroup=[];
let interval, touchStart=null;

init();
animate();
startTimer();

function playSound(id){ const audio=document.getElementById(id); if(audio){ audio.currentTime=0; audio.play(); } }

function init(){
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);

    camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(gridSize*cellSize/2, 20, gridSize*cellSize*1.2);
    camera.lookAt(gridSize*cellSize/2, 0, gridSize*cellSize/2);

    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const light = new THREE.DirectionalLight(0xffffff,1);
    light.position.set(10,50,10);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0xffffff,0.5));

    const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(gridSize*cellSize, gridSize*cellSize),
        new THREE.MeshStandardMaterial({color:0x333333})
    );
    floor.rotation.x=-Math.PI/2;
    scene.add(floor);

    generateMaze();
    createPlayer();
    createExit();
    updateStatus();

    window.addEventListener('keydown', handleKey);
    window.addEventListener('touchstart', e=>{ touchStart = e.touches[0]; });
    window.addEventListener('touchend', handleSwipe);
}

// --- Maze ---
function generateMaze(){
    mazeMap = Array(gridSize).fill(0).map(()=>Array(gridSize).fill(0));
    stars=[]; traps=[];

    // Remove previous objects
    for(let i=scene.children.length-1;i>=0;i--){
        const obj = scene.children[i];
        if(obj.userData && obj.userData.type && ["wall","star","trap","exit"].includes(obj.userData.type)){
            scene.remove(obj);
        }
    }

    for(let y=0;y<gridSize;y++){
        for(let x=0;x<gridSize;x++){
            if(x===0 && y===0){ mazeMap[y][x]=0; continue; }
            if(x===gridSize-1 && y===gridSize-1){ mazeMap[y][x]=4; exitPos={x,y}; createExitMesh(x,y); continue; }
            const rand=Math.random();
            if(rand<0.2){ mazeMap[y][x]=1; createWall(x,y); }
            else if(rand<0.3){ mazeMap[y][x]=2; createStar(x,y); }
            else if(rand<0.35){ mazeMap[y][x]=3; createTrap(x,y); }
            else mazeMap[y][x]=0;
        }
    }
}

function createWall(x,y){
    const cube = new THREE.Mesh(
        new THREE.BoxGeometry(cellSize,cellSize*0.7,cellSize),
        new THREE.MeshStandardMaterial({color:0x555555})
    );
    cube.position.set(x*cellSize+cellSize/2, cellSize*0.35, y*cellSize+cellSize/2);
    cube.castShadow=true; cube.userData.type="wall";
    scene.add(cube);
}

function createStar(x,y){
    const star = new THREE.Mesh(
        new THREE.BoxGeometry(cellSize/2, cellSize/2, cellSize/2),
        new THREE.MeshStandardMaterial({color:0xffff00})
    );
    star.position.set(x*cellSize+cellSize/2, cellSize/4, y*cellSize+cellSize/2);
    star.userData.type="star";
    scene.add(star);
    stars.push({x,y,mesh:star});
}

function createTrap(x,y){
    const trap = new THREE.Mesh(
        new THREE.BoxGeometry(cellSize/2, cellSize/4, cellSize/2),
        new THREE.MeshStandardMaterial({color:0x5555ff, emissive:0x0000ff, emissiveIntensity:0.3})
    );
    trap.position.set(x*cellSize+cellSize/2, cellSize/8, y*cellSize+cellSize/2);
    trap.userData.type="trap";
    scene.add(trap);
    traps.push({x,y,mesh:trap});
}

function createExitMesh(x,y){
    const exitMesh = new THREE.Mesh(
        new THREE.BoxGeometry(cellSize,cellSize,cellSize),
        new THREE.MeshStandardMaterial({color:0x55ff55})
    );
    exitMesh.position.set(x*cellSize+cellSize/2,cellSize/2,y*cellSize+cellSize/2);
    exitMesh.userData.type="exit";
    scene.add(exitMesh);
}

// --- Player ---
function createPlayer(){
    if(playerMesh) scene.remove(playerMesh);
    const geom = new THREE.BoxGeometry(cellSize*0.8,cellSize*0.8,cellSize*0.8);
    const mat = new THREE.MeshStandardMaterial({color:0xff5555});
    playerMesh = new THREE.Mesh(geom,mat);
    playerMesh.position.set(playerPos.x*cellSize+cellSize/2, cellSize/2, playerPos.y*cellSize+cellSize/2);
    scene.add(playerMesh);
}

// --- Controls ---
function canMove(nx,ny){ return nx>=0 && ny>=0 && nx<gridSize && ny<gridSize && mazeMap[ny][nx]!==1; }

function handleKey(e){
    let dx=0,dy=0;
    if(e.key==='ArrowUp'||e.key==='w') dy=-1;
    else if(e.key==='ArrowDown'||e.key==='s') dy=1;
    else if(e.key==='ArrowLeft'||e.key==='a') dx=-1;
    else if(e.key==='ArrowRight'||e.key==='d') dx=1;
    movePlayer(dx,dy);
}

function handleSwipe(e){
    if(!touchStart) return;
    const touchEnd = e.changedTouches[0];
    const dx = touchEnd.clientX - touchStart.clientX;
    const dy = touchEnd.clientY - touchStart.clientY;
    if(Math.abs(dx)>Math.abs(dy)) dx>0?movePlayer(1,0):movePlayer(-1,0);
    else dy>0?movePlayer(0,1):movePlayer(0,-1);
    touchStart=null;
}

function movePlayer(dx,dy){
    const nx=playerPos.x+dx, ny=playerPos.y+dy;
    if(!canMove(nx,ny)) return;
    playerPos.x=nx; playerPos.y=ny;
    playerMesh.position.set(nx*cellSize+cellSize/2, cellSize/2, ny*cellSize+cellSize/2);

    // Stars
    for(let i=stars.length-1;i>=0;i--){
        if(stars[i].x===nx && stars[i].y===ny){
            scene.remove(stars[i].mesh); stars.splice(i,1);
            score+=10; playSound('starSound'); updateStatus();
        }
    }

    // Traps
    for(let t of traps){ if(t.x===nx && t.y===ny){ timer=Math.max(1,timer-5); playSound('trapSound'); updateStatus(); } }

    // Exit
    if(nx===exitPos.x && ny===exitPos.y){
        playSound('levelUpSound');
        level++; gridSize=Math.min(gridSize+1,10); playerPos={x:0,y:0};
        generateMaze(); createPlayer(); updateStatus();
    }

    // Camera follow
    camera.position.set(playerMesh.position.x, camera.position.y, playerMesh.position.z + gridSize*cellSize*0.5);
    camera.lookAt(playerMesh.position);
}

// --- UI / Timer ---
function updateStatus(){
    document.getElementById('status').textContent = `Level: ${level} | Score: ${score} | Time: ${timer} | Highscore: ${highscore}`;
    if(score>highscore){ highscore=score; localStorage.setItem('miniMazeHighscore',highscore); }
}

function startTimer(){
    clearInterval(interval);
    interval=setInterval(()=>{
        timer--;
        if(timer<=0){
            alert('Time up!');
            level=1; gridSize=5; score=0; timer=30; generateMaze(); createPlayer(); updateStatus();
        }
        updateStatus();
    },1000);
}

// --- Animate ---
function animate(){
    requestAnimationFrame(animate);
    renderer.render(scene,camera);
}
</script>
</body>
</html>
