<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1-HP Dungeon</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.55.2/phaser.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
        }
        #game-container {
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    
    <script>
        // ===== GAME STATE =====
        const GameState = {
            fragments: parseInt(window.localStorage.getItem('fragments') || '0'),
            bestTime: parseFloat(window.localStorage.getItem('bestTime') || '0'),
            bestRooms: parseInt(window.localStorage.getItem('bestRooms') || '0'),
            totalKills: parseInt(window.localStorage.getItem('totalKills') || '0'),
            
            currentRun: {
                rooms: 0,
                kills: 0,
                time: 0,
                upgrades: []
            },
            
            save() {
                localStorage.setItem('fragments', this.fragments);
                localStorage.setItem('bestTime', this.bestTime);
                localStorage.setItem('bestRooms', this.bestRooms);
                localStorage.setItem('totalKills', this.totalKills);
            }
        };

        // ===== ROOM TEMPLATES =====
        const RoomTemplates = {
            empty: {
                enemies: [
                    { type: 'Charger', x: 0.7, y: 0.5 },
                    { type: 'Shooter', x: 0.3, y: 0.3 }
                ]
            },
            trap: {
                enemies: [
                    { type: 'Tracker', x: 0.8, y: 0.5 }
                ],
                traps: [
                    { x: 0.3, y: 0.7 },
                    { x: 0.5, y: 0.7 },
                    { x: 0.7, y: 0.7 }
                ]
            },
            pressure: {
                enemies: [
                    { type: 'Charger', x: 0.2, y: 0.5 },
                    { type: 'Charger', x: 0.8, y: 0.5 },
                    { type: 'Shooter', x: 0.5, y: 0.2 }
                ]
            },
            swarm: {
                enemies: [
                    { type: 'Tracker', x: 0.7, y: 0.3 },
                    { type: 'Tracker', x: 0.7, y: 0.7 },
                    { type: 'Shooter', x: 0.3, y: 0.5 }
                ]
            }
        };

        // ===== UPGRADE SYSTEM =====
        const Upgrades = {
            extraDash: {
                name: 'Extra Dash',
                desc: 'Gain +1 Dash Charge',
                apply: (player) => { player.maxDashes = 2; }
            },
            dashSlow: {
                name: 'Dash Time',
                desc: 'Slow-mo during dash',
                apply: (player) => { player.dashSlowmo = true; }
            },
            doubleJump: {
                name: 'Double Jump',
                desc: 'Jump twice',
                apply: (player) => { player.doubleJump = true; }
            },
            reflectDash: {
                name: 'Reflect Dash',
                desc: 'Reflect projectiles while dashing',
                apply: (player) => { player.reflectDash = true; }
            },
            killMomentum: {
                name: 'Kill Rush',
                desc: 'Speed boost on kill',
                apply: (player) => { player.killMomentum = true; }
            }
        };

        // ===== MAIN GAME SCENE =====
        class GameScene extends Phaser.Scene {
            constructor() {
                super({ key: 'GameScene' });
            }

            create() {
                this.cameras.main.setBackgroundColor('#1a1a2e');
                
                // Game variables
                this.roomCleared = false;
                this.difficulty = 1;
                this.coyoteTime = 0;
                this.jumpBuffer = 0;
                this.screenShake = 0;
                this.timeScale = 1;
                
                // Create player
                this.createPlayer();
                
                // Create groups
                this.enemies = this.add.group();
                this.projectiles = this.add.group();
                this.traps = this.add.group();
                
                // Input
                this.cursors = this.input.keyboard.createCursorKeys();
                this.keys = {
                    a: this.input.keyboard.addKey('A'),
                    d: this.input.keyboard.addKey('D'),
                    w: this.input.keyboard.addKey('W'),
                    space: this.input.keyboard.addKey('SPACE'),
                    shift: this.input.keyboard.addKey('SHIFT')
                };
                
                // UI
                this.createUI();
                
                // Start first room
                this.time.delayedCall(500, () => this.startNewRoom());
            }

            createPlayer() {
                this.player = this.add.rectangle(400, 300, 20, 30, 0x4ecca3);
                this.physics.add.existing(this.player);
                this.player.body.setCollideWorldBounds(true);
                this.player.body.setMaxVelocity(300, 600);
                this.player.body.setDrag(1000, 0);
                
                // Player stats
                this.player.hp = 1;
                this.player.maxDashes = 1;
                this.player.dashes = 1;
                this.player.isDashing = false;
                this.player.dashCooldown = 0;
                this.player.canAttack = true;
                this.player.attackCooldown = 0;
                this.player.isGrounded = false;
                this.player.hasDoubleJump = false;
                this.player.doubleJump = false;
                this.player.dashSlowmo = false;
                this.player.reflectDash = false;
                this.player.killMomentum = false;
                
                // Visual effects
                this.player.trail = [];
            }

            createUI() {
                // Time & Room
                this.timeText = this.add.text(20, 20, 'Time: 0.0s', {
                    fontSize: '18px',
                    color: '#fff'
                }).setScrollFactor(0).setDepth(100);
                
                this.roomText = this.add.text(20, 45, 'Room: 0', {
                    fontSize: '18px',
                    color: '#fff'
                }).setScrollFactor(0).setDepth(100);
                
                // Dash indicator
                this.dashIndicators = [];
                for (let i = 0; i < 2; i++) {
                    const dash = this.add.circle(750 - i * 35, 35, 12, 0x4ecca3, 0.3)
                        .setScrollFactor(0).setDepth(100);
                    this.dashIndicators.push(dash);
                }
                
                // Upgrades display
                this.upgradesText = this.add.text(20, 550, '', {
                    fontSize: '14px',
                    color: '#4ecca3'
                }).setScrollFactor(0).setDepth(100);
                
                // Feedback text
                this.feedbackText = this.add.text(400, 300, '', {
                    fontSize: '32px',
                    color: '#fff',
                    fontStyle: 'bold',
                    stroke: '#000',
                    strokeThickness: 4
                }).setOrigin(0.5).setScrollFactor(0).setDepth(100).setAlpha(0);
            }

            startNewRoom() {
                GameState.currentRun.rooms++;
                this.roomCleared = false;
                
                // Clear old enemies
                this.enemies.clear(true, true);
                this.projectiles.clear(true, true);
                this.traps.clear(true, true);
                
                // Select room template
                const templates = Object.keys(RoomTemplates);
                const template = RoomTemplates[templates[Phaser.Math.Between(0, templates.length - 1)]];
                
                // Spawn enemies
                template.enemies.forEach(enemy => {
                    this.spawnEnemy(enemy.type, enemy.x * 800, enemy.y * 600);
                });
                
                // Spawn traps
                if (template.traps) {
                    template.traps.forEach(trap => {
                        this.spawnTrap(trap.x * 800, trap.y * 600);
                    });
                }
                
                // Increase difficulty
                this.difficulty = 1 + GameState.currentRun.rooms * 0.1;
                
                this.showFeedback(`Room ${GameState.currentRun.rooms}`);
            }

            spawnEnemy(type, x, y) {
                const enemy = this.add.rectangle(x, y, 25, 25, 0xff6b6b);
                this.physics.add.existing(enemy);
                enemy.type = type;
                enemy.health = 1;
                enemy.state = 'idle';
                enemy.stateTimer = 0;
                enemy.attackCooldown = 0;
                
                this.enemies.add(enemy);
            }

            spawnTrap(x, y) {
                const trap = this.add.rectangle(x, y, 40, 10, 0xe74c3c);
                trap.active = false;
                trap.timer = 2000;
                this.traps.add(trap);
            }

            update(time, delta) {
                if (this.player.hp <= 0) return;
                
                // Update timers
                GameState.currentRun.time += delta / 1000;
                this.timeText.setText(`Time: ${GameState.currentRun.time.toFixed(1)}s`);
                this.roomText.setText(`Room: ${GameState.currentRun.rooms}`);
                
                // Time scale
                if (this.timeScale < 1) {
                    this.timeScale = Math.min(1, this.timeScale + delta * 0.003);
                }
                const adjustedDelta = delta * this.timeScale;
                
                // Player physics
                this.updatePlayer(adjustedDelta);
                
                // Enemies
                this.updateEnemies(adjustedDelta);
                
                // Projectiles
                this.updateProjectiles(adjustedDelta);
                
                // Traps
                this.updateTraps(adjustedDelta);
                
                // Check collisions
                this.checkCollisions();
                
                // Check room clear
                if (!this.roomCleared && this.enemies.getChildren().length === 0) {
                    this.roomCleared = true;
                    this.showFeedback('Room Clear!');
                    this.time.delayedCall(1500, () => this.showUpgradeChoice());
                }
                
                // Update UI
                this.updateUI();
            }

            updatePlayer(delta) {
                const player = this.player;
                const body = player.body;
                
                // Check grounded
                const wasGrounded = player.isGrounded;
                player.isGrounded = body.blocked.down || body.touching.down;
                
                if (player.isGrounded && !wasGrounded) {
                    player.dashes = player.maxDashes;
                    player.hasDoubleJump = false;
                }
                
                // Coyote time
                if (!player.isGrounded && wasGrounded) {
                    this.coyoteTime = 150;
                }
                this.coyoteTime = Math.max(0, this.coyoteTime - delta);
                
                // Jump buffer
                this.jumpBuffer = Math.max(0, this.jumpBuffer - delta);
                
                // Dash cooldown
                player.dashCooldown = Math.max(0, player.dashCooldown - delta);
                player.attackCooldown = Math.max(0, player.attackCooldown - delta);
                
                if (player.isDashing) {
                    player.dashTime = Math.max(0, player.dashTime - delta);
                    if (player.dashTime <= 0) {
                        player.isDashing = false;
                        this.timeScale = 1;
                    }
                }
                
                // Movement
                if (!player.isDashing) {
                    if (this.keys.a.isDown) {
                        body.setAccelerationX(-800);
                    } else if (this.keys.d.isDown) {
                        body.setAccelerationX(800);
                    } else {
                        body.setAccelerationX(0);
                    }
                }
                
                // Jump
                if ((this.keys.w.isDown || this.keys.space.isDown)) {
                    if (!this.lastJumpPressed) {
                        this.jumpBuffer = 100;
                    }
                    this.lastJumpPressed = true;
                } else {
                    this.lastJumpPressed = false;
                }
                
                if (this.jumpBuffer > 0) {
                    if (player.isGrounded || this.coyoteTime > 0) {
                        body.setVelocityY(-400);
                        this.jumpBuffer = 0;
                        this.coyoteTime = 0;
                    } else if (player.doubleJump && !player.hasDoubleJump) {
                        body.setVelocityY(-400);
                        player.hasDoubleJump = true;
                        this.jumpBuffer = 0;
                    }
                }
                
                // Dash
                if (this.keys.shift.isDown && !this.lastDashPressed && !player.isDashing && player.dashes > 0) {
                    this.performDash();
                    this.lastDashPressed = true;
                } else if (!this.keys.shift.isDown) {
                    this.lastDashPressed = false;
                }
                
                // Attack
                if (this.input.activePointer.isDown && player.attackCooldown <= 0) {
                    this.playerAttack();
                }
                
                // Trail effect
                if (player.isDashing) {
                    player.trail.push({ x: player.x, y: player.y, alpha: 1 });
                    if (player.trail.length > 5) player.trail.shift();
                }
                player.trail.forEach((t, i) => {
                    t.alpha -= delta * 0.005;
                });
                player.trail = player.trail.filter(t => t.alpha > 0);
            }

            performDash() {
                const player = this.player;
                let dashX = 0;
                
                if (this.keys.a.isDown) dashX = -1;
                else if (this.keys.d.isDown) dashX = 1;
                
                if (dashX === 0) dashX = player.body.velocity.x >= 0 ? 1 : -1;
                
                player.body.setVelocityX(dashX * 500);
                player.isDashing = true;
                player.dashTime = 200;
                player.dashes--;
                player.dashCooldown = 500;
                
                if (player.dashSlowmo) {
                    this.timeScale = 0.3;
                }
                
                this.cameras.main.shake(50, 0.003);
            }

            playerAttack() {
                const player = this.player;
                const pointer = this.input.activePointer;
                
                const angle = Phaser.Math.Angle.Between(
                    player.x, player.y,
                    pointer.x, pointer.y
                );
                
                const projectile = this.add.circle(player.x, player.y, 5, 0x4ecca3);
                this.physics.add.existing(projectile);
                projectile.body.setVelocity(
                    Math.cos(angle) * 400,
                    Math.sin(angle) * 400
                );
                projectile.isPlayer = true;
                this.projectiles.add(projectile);
                
                player.attackCooldown = 300;
            }

            updateEnemies(delta) {
                this.enemies.getChildren().forEach(enemy => {
                    if (!enemy.active) return;
                    
                    enemy.stateTimer += delta;
                    enemy.attackCooldown = Math.max(0, enemy.attackCooldown - delta);
                    
                    const distToPlayer = Phaser.Math.Distance.Between(
                        enemy.x, enemy.y,
                        this.player.x, this.player.y
                    );
                    
                    switch (enemy.type) {
                        case 'Charger':
                            this.updateCharger(enemy, distToPlayer, delta);
                            break;
                        case 'Shooter':
                            this.updateShooter(enemy, distToPlayer, delta);
                            break;
                        case 'Tracker':
                            this.updateTracker(enemy, distToPlayer, delta);
                            break;
                    }
                });
            }

            updateCharger(enemy, distToPlayer, delta) {
                switch (enemy.state) {
                    case 'idle':
                        if (distToPlayer < 300 && enemy.attackCooldown <= 0) {
                            enemy.state = 'windup';
                            enemy.stateTimer = 0;
                            enemy.setFillStyle(0xff9999);
                        }
                        break;
                    case 'windup':
                        if (enemy.stateTimer > 800) {
                            enemy.state = 'charge';
                            const angle = Phaser.Math.Angle.Between(
                                enemy.x, enemy.y,
                                this.player.x, this.player.y
                            );
                            enemy.body.setVelocity(
                                Math.cos(angle) * 300 * this.difficulty,
                                Math.sin(angle) * 300 * this.difficulty
                            );
                            enemy.stateTimer = 0;
                        }
                        break;
                    case 'charge':
                        if (enemy.stateTimer > 1000) {
                            enemy.state = 'idle';
                            enemy.body.setVelocity(0, 0);
                            enemy.attackCooldown = 2000;
                            enemy.setFillStyle(0xff6b6b);
                        }
                        break;
                }
            }

            updateShooter(enemy, distToPlayer, delta) {
                if (distToPlayer < 400 && enemy.attackCooldown <= 0) {
                    const angle = Phaser.Math.Angle.Between(
                        enemy.x, enemy.y,
                        this.player.x, this.player.y
                    );
                    
                    const projectile = this.add.circle(enemy.x, enemy.y, 6, 0xff6b6b);
                    this.physics.add.existing(projectile);
                    projectile.body.setVelocity(
                        Math.cos(angle) * 200,
                        Math.sin(angle) * 200
                    );
                    projectile.isEnemy = true;
                    this.projectiles.add(projectile);
                    
                    enemy.attackCooldown = 2000 / this.difficulty;
                }
            }

            updateTracker(enemy, distToPlayer, delta) {
                const speed = 80 * this.difficulty;
                const angle = Phaser.Math.Angle.Between(
                    enemy.x, enemy.y,
                    this.player.x, this.player.y
                );
                
                enemy.body.setVelocity(
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed
                );
            }

            updateProjectiles(delta) {
                this.projectiles.getChildren().forEach(proj => {
                    if (!proj.active) return;
                    
                    if (proj.x < 0 || proj.x > 800 || proj.y < 0 || proj.y > 600) {
                        proj.destroy();
                    }
                });
            }

            updateTraps(delta) {
                this.traps.getChildren().forEach(trap => {
                    trap.timer -= delta;
                    if (trap.timer <= 0) {
                        trap.active = !trap.active;
                        trap.setFillStyle(trap.active ? 0xff0000 : 0xe74c3c);
                        trap.timer = trap.active ? 1000 : 2000;
                    }
                });
            }

            checkCollisions() {
                // Player hit by enemy projectile
                this.projectiles.getChildren().forEach(proj => {
                    if (!proj.isEnemy) return;
                    
                    if (this.checkOverlap(this.player, proj)) {
                        if (this.player.isDashing && this.player.reflectDash) {
                            proj.isEnemy = false;
                            proj.isPlayer = true;
                            proj.body.velocity.x *= -1;
                            proj.body.velocity.y *= -1;
                        } else {
                            this.playerDeath();
                        }
                    }
                });
                
                // Player hit by enemy
                this.enemies.getChildren().forEach(enemy => {
                    if (this.checkOverlap(this.player, enemy) && !this.player.isDashing) {
                        this.playerDeath();
                    }
                });
                
                // Player hit by trap
                this.traps.getChildren().forEach(trap => {
                    if (trap.active && this.checkOverlap(this.player, trap) && !this.player.isDashing) {
                        this.playerDeath();
                    }
                });
                
                // Player projectile hit enemy
                this.projectiles.getChildren().forEach(proj => {
                    if (!proj.isPlayer) return;
                    
                    this.enemies.getChildren().forEach(enemy => {
                        if (this.checkOverlap(enemy, proj)) {
                            enemy.destroy();
                            proj.destroy();
                            GameState.currentRun.kills++;
                            
                            if (this.player.killMomentum) {
                                this.player.body.setMaxVelocity(400, 600);
                                this.time.delayedCall(1000, () => {
                                    this.player.body.setMaxVelocity(300, 600);
                                });
                            }
                            
                            this.cameras.main.shake(100, 0.002);
                        }
                    });
                });
            }

            checkOverlap(obj1, obj2) {
                const bounds1 = obj1.getBounds();
                const bounds2 = obj2.getBounds();
                return Phaser.Geom.Intersects.RectangleToRectangle(bounds1, bounds2);
            }

            playerDeath() {
                if (this.player.hp <= 0) return;
                
                this.player.hp = 0;
                this.player.setFillStyle(0x000000);
                
                // Death effects
                this.cameras.main.shake(500, 0.01);
                this.cameras.main.flash(500, 255, 0, 0);
                this.time.timeScale = 0.1;
                
                this.time.delayedCall(100, () => {
                    this.time.timeScale = 1;
                });
                
                this.time.delayedCall(1000, () => {
                    this.showDeathScreen();
                });
            }

            showDeathScreen() {
                // Save stats
                GameState.fragments += Math.floor(GameState.currentRun.rooms * 10 + GameState.currentRun.kills * 5);
                if (GameState.currentRun.time > GameState.bestTime) {
                    GameState.bestTime = GameState.currentRun.time;
                }
                if (GameState.currentRun.rooms > GameState.bestRooms) {
                    GameState.bestRooms = GameState.currentRun.rooms;
                }
                GameState.totalKills += GameState.currentRun.kills;
                GameState.save();
                
                this.scene.start('DeathScene');
            }

            showUpgradeChoice() {
                const upgradeKeys = Object.keys(Upgrades);
                const choices = [];
                
                for (let i = 0; i < 3; i++) {
                    const key = upgradeKeys[Phaser.Math.Between(0, upgradeKeys.length - 1)];
                    choices.push({ key, ...Upgrades[key] });
                }
                
                const bg = this.add.rectangle(400, 300, 600, 400, 0x000000, 0.9)
                    .setScrollFactor(0).setDepth(200);
                
                const title = this.add.text(400, 150, 'Choose Upgrade', {
                    fontSize: '32px',
                    color: '#4ecca3'
                }).setOrigin(0.5).setScrollFactor(0).setDepth(201);
                
                choices.forEach((choice, i) => {
                    const y = 250 + i * 80;
                    const btn = this.add.rectangle(400, y, 500, 60, 0x1a1a2e)
                        .setScrollFactor(0).setDepth(201).setInteractive();
                    
                    const text = this.add.text(400, y, `${choice.name}\n${choice.desc}`, {
                        fontSize: '16px',
                        color: '#fff',
                        align: 'center'
                    }).setOrigin(0.5).setScrollFactor(0).setDepth(202);
                    
                    btn.on('pointerover', () => btn.setFillStyle(0x2a2a3e));
                    btn.on('pointerout', () => btn.setFillStyle(0x1a1a2e));
                    btn.on('pointerdown', () => {
                        choice.apply(this.player);
                        GameState.currentRun.upgrades.push(choice.name);
                        bg.destroy();
                        title.destroy();
                        btn.destroy();
                        text.destroy();
                        this.startNewRoom();
                    });
                });
            }

            showFeedback(text) {
                this.feedbackText.setText(text);
                this.tweens.add({
                    targets: this.feedbackText,
                    alpha: 1,
                    duration: 200,
                    yoyo: true,
                    hold: 500
                });
            }

            updateUI() {
                // Update dash indicators
                this.dashIndicators.forEach((indicator, i) => {
                    indicator.setAlpha(i < this.player.dashes ? 1 : 0.3);
                });
                
                // Update upgrades
                this.upgradesText.setText(GameState.currentRun.upgrades.join(' | '));
            }
        }

        // ===== DEATH SCENE =====
        class DeathScene extends Phaser.Scene {
            constructor() {
                super({ key: 'DeathScene' });
            }

            create() {
                this.cameras.main.setBackgroundColor('#000000');
                
                this.add.text(400, 100, 'YOU DIED', {
                    fontSize: '64px',
                    color: '#ff0000',
                    fontStyle: 'bold'
                }).setOrigin(0.5);
                
                this.add.text(400, 200, `Rooms Cleared: ${GameState.currentRun.rooms}`, {
                    fontSize: '24px',
                    color: '#fff'
                }).setOrigin(0.5);
                
                this.add.text(400, 240, `Kills: ${GameState.currentRun.kills}`, {
                    fontSize: '24px',
                    color: '#fff'
                }).setOrigin(0.5);
                
                this.add.text(400, 280, `Time: ${GameState.currentRun.time.toFixed(1)}s`, {
                    fontSize: '24px',
                    color: '#fff'
                }).setOrigin(0.5);
                
                this.add.text(400, 320, `Fragments Earned: ${Math.floor(GameState.currentRun.rooms * 10 + GameState.currentRun.kills * 5)}`, {
                    fontSize: '24px',
                    color: '#4ecca3'
                }).setOrigin(0.5);
                
                const restartBtn = this.add.rectangle(400, 450, 300, 60, 0x4ecca3)
                    .setInteractive();
                
                this.add.text(400, 450, 'RESTART', {
                    fontSize: '32px',
                    color: '#000',
                    fontStyle: 'bold'
                }).setOrigin(0.5);
                
                restartBtn.on('pointerover', () => restartBtn.setFillStyle(0x45b393));
                restartBtn.on('pointerout', () => restartBtn.setFillStyle(0x4ecca3));
                restartBtn.on('pointerdown', () => {
                    GameState.currentRun = { rooms: 0, kills: 0, time: 0, upgrades: [] };
                    this.scene.start('GameScene');
                });
            }
        }

        // ===== PHASER CONFIG =====
        const config = {
            type: Phaser.AUTO,
            width: 800,
            height: 600,
            parent: 'game-container',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 800 },
                    debug: false
                }
            },
            scene: [GameScene, DeathScene]
        };

        const game = new Phaser.Game(config);
    </script>
</body>
</html>