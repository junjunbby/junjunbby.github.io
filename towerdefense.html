<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Tower Defense ‚Äì Save / Load</title>
<style>
body{
  margin:0;
  background:#111;
  color:#fff;
  font-family:Arial;
  display:flex;
  justify-content:center;
  align-items:center;
  height:100vh;
}
#ui{
  margin-bottom:6px;
  display:flex;
  gap:6px;
}
button{
  padding:6px 10px;
  border:none;
  border-radius:4px;
  cursor:pointer;
  font-weight:bold;
}
canvas{
  background:#1a1a1a;
  border:3px solid #4CAF50;
}
#upgradePanel{
  margin-top:6px;
  display:none;
  gap:6px;
}
</style>
</head>
<body>

<div>
  <div id="ui">
    üí∞ <span id="money">200</span>
    ‚ù§Ô∏è <span id="lives">20</span>
    üåä <span id="wave">0</span>
    <button onclick="startWave()">Start</button>
    <button onclick="saveGame()">üíæ Save</button>
    <button onclick="resetGame()">üóëÔ∏è Reset</button>
  </div>

  <canvas id="game" width="600" height="400"></canvas>

  <div id="upgradePanel">
    <button onclick="upgrade('dmg')">+DMG ($40)</button>
    <button onclick="upgrade('range')">+Range ($30)</button>
    <button onclick="upgrade('speed')">+Speed ($35)</button>
  </div>
</div>

<script>
const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");
const GRID=40;

let money=200,lives=20,wave=0;
let towers=[],enemies=[];
let selectedTower=null;
let waveActive=false;

const path=[
  {x:0,y:5},{x:5,y:5},{x:5,y:2},
  {x:10,y:2},{x:10,y:7},{x:14,y:7}
];

class Tower{
  constructor(x,y){
    this.x=x;this.y=y;
    this.level=1;
    this.dmg=10;
    this.range=120;
    this.fireRate=30;
    this.cooldown=0;
    this.totalCost=50;
  }
  upgrade(type){
    const cost={dmg:40,range:30,speed:35}[type];
    if(money<cost) return;
    money-=cost;
    this.level++;
    this.totalCost+=cost;
    if(type==="dmg") this.dmg+=5;
    if(type==="range") this.range+=20;
    if(type==="speed") this.fireRate=Math.max(10,this.fireRate-5);
  }
  update(){
    if(this.cooldown>0){this.cooldown--;return;}
    const tx=this.x*GRID+GRID/2;
    const ty=this.y*GRID+GRID/2;
    for(const e of enemies){
      const d=Math.hypot(e.x-tx,e.y-ty);
      if(d<this.range){
        e.hp-=this.dmg;
        this.cooldown=this.fireRate;
        break;
      }
    }
  }
  draw(){
    const px=this.x*GRID+GRID/2;
    const py=this.y*GRID+GRID/2;
    ctx.fillStyle="#4CAF50";
    ctx.beginPath();
    ctx.arc(px,py,14,0,Math.PI*2);
    ctx.fill();
    ctx.fillStyle="#FFD700";
    ctx.font="10px Arial";
    ctx.textAlign="center";
    ctx.fillText(this.level,px,py+4);

    if(this===selectedTower){
      ctx.strokeStyle="rgba(0,255,0,.3)";
      ctx.beginPath();
      ctx.arc(px,py,this.range,0,Math.PI*2);
      ctx.stroke();
    }
  }
}

class Enemy{
  constructor(){
    this.hp=30+wave*5;
    this.speed=1;
    this.pathIdx=0;
    this.x=path[0].x*GRID+GRID/2;
    this.y=path[0].y*GRID+GRID/2;
  }
  update(){
    if(this.hp<=0){
      money+=10;
      return true;
    }
    if(this.pathIdx>=path.length-1){
      lives--;
      return true;
    }
    const next=path[this.pathIdx+1];
    const tx=next.x*GRID+GRID/2;
    const ty=next.y*GRID+GRID/2;
    const dx=tx-this.x,dy=ty-this.y;
    const d=Math.hypot(dx,dy);
    if(d<this.speed) this.pathIdx++;
    else{
      this.x+=dx/d*this.speed;
      this.y+=dy/d*this.speed;
    }
    return false;
  }
  draw(){
    ctx.fillStyle="#e74c3c";
    ctx.beginPath();
    ctx.arc(this.x,this.y,10,0,Math.PI*2);
    ctx.fill();
  }
}

canvas.addEventListener("click",e=>{
  const r=canvas.getBoundingClientRect();
  const gx=Math.floor((e.clientX-r.left)/GRID);
  const gy=Math.floor((e.clientY-r.top)/GRID);

  const t=towers.find(t=>t.x===gx&&t.y===gy);
  if(t){
    selectedTower=t;
    document.getElementById("upgradePanel").style.display="flex";
    return;
  }

  if(path.some(p=>p.x===gx&&p.y===gy)) return;
  if(money<50) return;

  towers.push(new Tower(gx,gy));
  money-=50;
});

function upgrade(type){
  if(selectedTower) selectedTower.upgrade(type);
}

function startWave(){
  if(waveActive) return;
  wave++;waveActive=true;
  for(let i=0;i<5+wave;i++){
    setTimeout(()=>enemies.push(new Enemy()),i*600);
  }
}

function saveGame(){
  const data={
    money,lives,wave,
    towers:towers.map(t=>({
      x:t.x,y:t.y,level:t.level,
      dmg:t.dmg,range:t.range,fireRate:t.fireRate,totalCost:t.totalCost
    }))
  };
  localStorage.setItem("td_save",JSON.stringify(data));
}

function loadGame(){
  const raw=localStorage.getItem("td_save");
  if(!raw) return;
  const d=JSON.parse(raw);
  money=d.money;lives=d.lives;wave=d.wave;
  towers=[];
  d.towers.forEach(t=>{
    const nt=new Tower(t.x,t.y);
    Object.assign(nt,t);
    towers.push(nt);
  });
}

function resetGame(){
  localStorage.removeItem("td_save");
  location.reload();
}

function drawMap(){
  ctx.fillStyle="#2ecc71";
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.strokeStyle="#ccc";
  ctx.lineWidth=GRID*0.6;
  ctx.beginPath();
  path.forEach((p,i)=>{
    const px=p.x*GRID+GRID/2;
    const py=p.y*GRID+GRID/2;
    if(i===0) ctx.moveTo(px,py);
    else ctx.lineTo(px,py);
  });
  ctx.stroke();
}

function loop(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawMap();

  towers.forEach(t=>{t.update();t.draw();});
  enemies=enemies.filter(e=>!e.update());
  enemies.forEach(e=>e.draw());

  document.getElementById("money").textContent=money;
  document.getElementById("lives").textContent=lives;
  document.getElementById("wave").textContent=wave;

  if(enemies.length===0) waveActive=false;

  requestAnimationFrame(loop);
}

loadGame();
loop();
</script>

</body>
</html>
