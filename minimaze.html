<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Mini-Maze 2.5D Arcade Fixed</title>
<style>
body { margin:0; overflow:hidden; font-family:sans-serif; touch-action: none; background:#222; }
#ui {
  position:absolute; top:10px; left:10px;
  background: rgba(255,255,255,0.85); padding:10px; border-radius:8px;
  z-index:10;
}
#ui h3 { margin:0 0 5px 0; color:#333; }
#ui p { margin:2px 0; color:#222; }
</style>
</head>
<body>
<div id="ui">
  <h3>Mini-Maze 2.5D Arcade Fixed</h3>
  <p>Arrow keys / WASD / swipe: move</p>
  <p id="status">Level: 1 | Score: 0 | Time: 30 | Highscore: 0</p>
</div>

<!-- Audio -->
<audio id="starSound" src="https://freesound.org/data/previews/320/320655_5260876-lq.mp3"></audio>
<audio id="trapSound" src="https://freesound.org/data/previews/198/198841_2859976-lq.mp3"></audio>
<audio id="exitSound" src="https://freesound.org/data/previews/331/331912_3248244-lq.mp3"></audio>
<audio id="levelUpSound" src="https://freesound.org/data/previews/146/146725_2615114-lq.mp3"></audio> <!-- New level-up sound -->

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/gsap.min.js"></script>
<script>
let scene, camera, renderer;
let gridSize=5, cellSize=4, level=1, score=0, timer=30, highscore=localStorage.getItem('miniMazeHighscore')||0;
let mazeMap=[], stars=[], traps=[], particlesGroup=[];
let playerPos={x:0,y:0}, playerMesh, exitPos={x:0,y:0};
let interval, touchStart=null;

init(); animate(); startTimer();

function playSound(id){ const audio=document.getElementById(id); if(audio){ audio.currentTime=0; audio.play(); } }

function init(){
  scene = new THREE.Scene(); scene.background = new THREE.Color(0x222222);

  camera = new THREE.PerspectiveCamera(50,window.innerWidth/window.innerHeight,0.1,1000);
  camera.position.set(gridSize*cellSize/2, gridSize*cellSize*1.8, gridSize*cellSize/1.5);
  camera.lookAt(gridSize*cellSize/2,0,gridSize*cellSize/2);

  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth,window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  document.body.appendChild(renderer.domElement);

  const dirLight = new THREE.DirectionalLight(0xffffff,1);
  dirLight.position.set(10,50,10);
  dirLight.castShadow=true;
  scene.add(dirLight);
  scene.add(new THREE.AmbientLight(0xffffff,0.5));

  const floor = new THREE.Mesh(new THREE.PlaneGeometry(gridSize*cellSize, gridSize*cellSize),
      new THREE.MeshStandardMaterial({color:0x333333, metalness:0.5, roughness:0.3}));
  floor.rotation.x=-Math.PI/2;
  floor.receiveShadow = true;
  scene.add(floor);

  generateMaze(); createPlayer(); updateStatus();

  window.addEventListener('keydown',handleKey);
  window.addEventListener('touchstart',e=>{ touchStart=e.touches[0]; });
  window.addEventListener('touchend',handleSwipe);
}

// --- Maze Generation ---
function generateMaze(){
  mazeMap=Array(gridSize).fill(0).map(()=>Array(gridSize).fill(0));
  stars=[]; traps=[];

  // Remove previous objects
  scene.children = scene.children.filter(c => c.type!=="Mesh" || c.geometry.type==="PlaneGeometry");

  for(let y=0;y<gridSize;y++){
    for(let x=0;x<gridSize;x++){
      if(x===0 && y===0){ mazeMap[y][x]=0; continue; }
      if(x===gridSize-1 && y===gridSize-1){ mazeMap[y][x]=4; exitPos={x,y}; continue; }

      const rand=Math.random();
      if(rand<0.2){ mazeMap[y][x]=1; createWall(x,y); }
      else if(rand<0.3){ mazeMap[y][x]=2; createStar(x,y); }
      else if(rand<0.35){ mazeMap[y][x]=3; createTrap(x,y); }
      else mazeMap[y][x]=0;
    }
  }
}

function createWall(x,y){
  const cube = new THREE.Mesh(new THREE.BoxGeometry(cellSize,cellSize*0.7,cellSize),
    new THREE.MeshStandardMaterial({color:0x555555}));
  cube.position.set(x*cellSize+cellSize/2,cellSize*0.35,y*cellSize+cellSize/2);
  cube.castShadow=true; scene.add(cube);
}

function createStar(x,y){
  const star = new THREE.Mesh(new THREE.BoxGeometry(cellSize/2,cellSize/2,cellSize/2),
    new THREE.MeshStandardMaterial({color:0xffff00}));
  star.position.set(x*cellSize+cellSize/2,cellSize/4,y*cellSize+cellSize/2);
  star.castShadow=true; scene.add(star);
  stars.push({x,y,mesh:star});
}

function createTrap(x,y){
  const trap = new THREE.Mesh(new THREE.BoxGeometry(cellSize/2,cellSize/4,cellSize/2),
    new THREE.MeshStandardMaterial({color:0x5555ff, emissive:0x0000ff, emissiveIntensity:0.3}));
  trap.position.set(x*cellSize+cellSize/2,cellSize/8,y*cellSize+cellSize/2);
  trap.castShadow=true; scene.add(trap);
  traps.push({x,y,mesh:trap});
}

// --- Player ---
function createPlayer(){
  if(playerMesh) scene.remove(playerMesh);
  const geom = new THREE.BoxGeometry(cellSize*0.8,cellSize*0.8,cellSize*0.8);
  const mat = new THREE.MeshStandardMaterial({color:0xff5555});
  playerMesh = new THREE.Mesh(geom,mat);
  playerMesh.position.set(playerPos.x*cellSize+cellSize/2,cellSize/2,playerPos.y*cellSize+cellSize/2);
  playerMesh.castShadow=true;
  scene.add(playerMesh);
}

// --- Controls ---
function handleKey(e){ let dx=0,dy=0;
  if(e.key==='ArrowUp'||e.key==='w'||e.key==='W') dy=-1;
  else if(e.key==='ArrowDown'||e.key==='s'||e.key==='S') dy=1;
  else if(e.key==='ArrowLeft'||e.key==='a'||e.key==='A') dx=-1;
  else if(e.key==='ArrowRight'||e.key==='d'||e.key==='D') dx=1;
  movePlayer(dx,dy);
}

function handleSwipe(e){
  if(!touchStart) return;
  const touchEnd = e.changedTouches[0];
  const dx = touchEnd.clientX - touchStart.clientX;
  const dy = touchEnd.clientY - touchStart.clientY;
  if(Math.abs(dx)>Math.abs(dy)){ dx>0?movePlayer(1,0):movePlayer(-1,0); } 
  else { dy>0?movePlayer(0,1):movePlayer(0,-1); }
  touchStart=null;
}

// --- Movement & Collisions ---
function canMove(nx,ny){ return nx>=0 && ny>=0 && nx<gridSize && ny<gridSize && mazeMap[ny][nx]!==1; }

function movePlayer(dx,dy){
  const nx=playerPos.x+dx, ny=playerPos.y+dy;
  if(!canMove(nx,ny)) return;
  playerPos.x=nx; playerPos.y=ny;

  gsap.to(playerMesh.position,{duration:0.15, x:nx*cellSize+cellSize/2, z=ny*cellSize+cellSize/2});
  gsap.to(scene.rotation,{duration:0.12, x:dy*0.04, z:-dx*0.04, yoyo:true, repeat:1});

  // Stars
  for(let i=stars.length-1;i>=0;i--){
    if(stars[i].x===nx && stars[i].y===ny){
      spawnParticles(playerMesh.position.x,playerMesh.position.y,playerMesh.position.z,0xffff00);
      shakeCamera(0.12,0.12);
      scene.remove(stars[i].mesh); stars.splice(i,1);
      score+=10; playSound('starSound'); updateStatus();
    }
  }

  // Traps
  for(let t of traps){ if(t.x===nx && t.y===ny){ shakeCamera(0.2,0.15); playSound('trapSound'); timer=Math.max(1,timer-5); updateStatus(); } }

  // Exit
  if(nx===exitPos.x && ny===exitPos.y){
    spawnParticles(playerMesh.position.x,playerMesh.position.y,playerMesh.position.z,0x00ff00);
    shakeCamera(0.25,0.2);
    playSound('levelUpSound'); // NEW sound for next level
    level++; gridSize=Math.min(gridSize+1,10); playerPos={x:0,y:0};
    generateMaze(); createPlayer(); updateStatus();
  }
}

// --- Particles & Camera Shake ---
function spawnParticles(x,y,z,color=0xffff00){
  const geom = new THREE.BufferGeometry();
  const vertices=[]; for(let i=0;i<30;i++) vertices.push(x,y,z);
  geom.setAttribute('position', new THREE.Float32BufferAttribute(vertices,3));
  const mat = new THREE.PointsMaterial({color,size:0.3});
  const points = new THREE.Points(geom,mat); scene.add(points);
  particlesGroup.push({points,life:30});
}

function shakeCamera(intensity=0.2,duration=0.15){
  const orig = camera.position.clone();
  gsap.to(camera.position,{
    duration:duration,
    x: orig.x + (Math.random()-0.5)*intensity,
    y: orig.y + (Math.random()-0.5)*intensity,
    z: orig.z + (Math.random()-0.5)*intensity,
    yoyo:true, repeat:1,
    onComplete:()=>{ camera.position.copy(orig); }
  });
}

// --- UI / Timer ---
function updateStatus(){
  document.getElementById('status').textContent=
    `Level: ${level} | Score: ${score} | Time: ${timer} | Highscore: ${highscore}`;
  if(score>highscore){ highscore=score; localStorage.setItem('miniMazeHighscore',highscore);}
}

function startTimer(){
  clearInterval(interval);
  interval=setInterval(()=>{
    timer--; if(timer<=0){
      alert('Time up!');
      if(score>highscore){ highscore=score; localStorage.setItem('miniMazeHighscore',highscore); alert('New Highscore: '+highscore);}
      level=1; gridSize=5; score=0; timer=30; generateMaze(); createPlayer(); updateStatus();
    }
    updateStatus();
  },1000);
}

// --- Animate ---
function animate(){
  requestAnimationFrame(animate);

  for(let s of stars) s.mesh.rotation.y+=0.02;
  for(let t of traps) t.mesh.material.emissiveIntensity=0.3+0.2*Math.sin(Date.now()*0.01);

  gsap.to(camera.position,{duration:0.15, x:playerMesh.position.x + gridSize, z:playerMesh.position.z + gridSize});
  camera.lookAt(playerMesh.position);

  for(let i=particlesGroup.length-1;i>=0;i--){
    const p=particlesGroup[i]; const pos=p.points.geometry.attributes.position.array;
    for(let j=0;j<pos.length;j+=3){
      pos[j]+=(Math.random()-0.5)*0.2; pos[j+1]+=(Math.random()*0.2); pos[j+2]+=(Math.random()-0.5)*0.2;
    }
    p.points.geometry.attributes.position.needsUpdate=true; p.life--;
    if(p.life<=0){ scene.remove(p.points); particlesGroup.splice(i,1); }
  }

  renderer.render(scene,camera);
}
</script>
</body>
</html>
