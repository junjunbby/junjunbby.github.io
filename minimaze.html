<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Mini-Maze 3D Arcade Deluxe Particles</title>
<style>
body { margin:0; overflow:hidden; font-family:sans-serif; touch-action: none; }
#ui {
  position:absolute; top:10px; left:10px;
  background: rgba(255,255,255,0.8); padding:10px; border-radius:8px;
  z-index:10;
}
#ui h3 { margin:0 0 5px 0; }
#ui p { margin:2px 0; }
</style>
</head>
<body>
<div id="ui">
  <h3>Mini-Maze 3D Arcade Deluxe</h3>
  <p>Arrow keys / WASD / swipe: move</p>
  <p id="status">Level: 1 | Score: 0 | Time: 30 | Highscore: 0</p>
</div>

<!-- Audio -->
<audio id="starSound" src="https://freesound.org/data/previews/320/320655_5260876-lq.mp3"></audio>
<audio id="trapSound" src="https://freesound.org/data/previews/198/198841_2859976-lq.mp3"></audio>
<audio id="exitSound" src="https://freesound.org/data/previews/331/331912_3248244-lq.mp3"></audio>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/gsap.min.js"></script>
<script>
let scene, camera, renderer;
let gridSize=5, cellSize=4, level=1, score=0, timer=30, highscore=localStorage.getItem('miniMazeHighscore')||0;
let maze=[], stars=[], traps=[];
let playerPos={x:0,y:0}, playerMesh, exitMesh;
let interval;
let touchStart = null;
let particlesGroup = [];

init(); animate(); startTimer();

function playSound(id){ const audio=document.getElementById(id); if(audio){ audio.currentTime=0; audio.play(); } }

function init(){
  scene = new THREE.Scene(); scene.background = new THREE.Color(0xeeeeee);
  camera = new THREE.PerspectiveCamera(50,window.innerWidth/window.innerHeight,0.1,1000);
  camera.position.set(gridSize*cellSize/2, gridSize*cellSize*1.5, gridSize*cellSize);
  camera.lookAt(gridSize*cellSize/2,0,gridSize*cellSize/2);
  renderer = new THREE.WebGLRenderer({antialias:true}); renderer.setSize(window.innerWidth,window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const light = new THREE.DirectionalLight(0xffffff,1); light.position.set(0,50,50); scene.add(light);
  scene.add(new THREE.AmbientLight(0xffffff,0.5));

  const floor = new THREE.Mesh(new THREE.PlaneGeometry(gridSize*cellSize, gridSize*cellSize),
      new THREE.MeshStandardMaterial({color:0xaaaaaa}));
  floor.rotation.x=-Math.PI/2; scene.add(floor);

  createMaze(); createPlayer(); createExit();

  window.addEventListener('keydown',handleKey);
  window.addEventListener('touchstart',e=>{ touchStart = e.touches[0]; });
  window.addEventListener('touchend',handleSwipe);
}

// --- Maze / Player / Exit ---
function createMaze(){
  for(let obj of maze) scene.remove(obj); maze=[];
  for(let s of stars) scene.remove(s.mesh); stars=[];
  for(let t of traps) scene.remove(t.mesh); traps=[];

  for(let y=0;y<gridSize;y++){
    for(let x=0;x<gridSize;x++){
      let cellType='path';
      if(Math.random()<0.2 && !(x===0&&y===0) && !(x===gridSize-1&&y===gridSize-1)) cellType='wall';
      else if(Math.random()<0.05) cellType='trap';
      else if(Math.random()<0.1) cellType='star';

      if(cellType==='wall'){
        const cube = new THREE.Mesh(new THREE.BoxGeometry(cellSize,cellSize,cellSize),
          new THREE.MeshStandardMaterial({color:0x333333}));
        cube.position.set(x*cellSize+cellSize/2,cellSize/2,y*cellSize+cellSize/2);
        scene.add(cube); maze.push(cube);
      } else if(cellType==='star'){
        const star = new THREE.Mesh(new THREE.BoxGeometry(cellSize/2,cellSize/2,cellSize/2),
          new THREE.MeshStandardMaterial({color:0xffff00}));
        star.position.set(x*cellSize+cellSize/2,cellSize/4,y*cellSize+cellSize/2);
        scene.add(star); stars.push({mesh:star,x,y});
      } else if(cellType==='trap'){
        const trap = new THREE.Mesh(new THREE.BoxGeometry(cellSize/2,cellSize/4,cellSize/2),
          new THREE.MeshStandardMaterial({color:0x5555ff, emissive:0x0000ff, emissiveIntensity:0.3}));
        trap.position.set(x*cellSize+cellSize/2,cellSize/8,y*cellSize+cellSize/2);
        scene.add(trap); traps.push({mesh:trap,x,y});
      }
    }
  }
}

function createPlayer(){
  const geom = new THREE.BoxGeometry(cellSize*0.8,cellSize*0.8,cellSize*0.8);
  const mat = new THREE.MeshStandardMaterial({color:0xff5555});
  playerMesh = new THREE.Mesh(geom,mat);
  playerMesh.position.set(cellSize/2,cellSize/2,cellSize/2);
  scene.add(playerMesh);
}

function createExit(){
  const geom = new THREE.BoxGeometry(cellSize,cellSize,cellSize);
  const mat = new THREE.MeshStandardMaterial({color:0x55ff55});
  exitMesh = new THREE.Mesh(geom,mat);
  exitMesh.position.set((gridSize-1)*cellSize+cellSize/2,cellSize/2,(gridSize-1)*cellSize+cellSize/2);
  scene.add(exitMesh);
}

// --- Controls ---
function handleKey(e){
  let dx=0,dy=0;
  if(e.key==='ArrowUp'||e.key==='w'||e.key==='W') dy=-1;
  else if(e.key==='ArrowDown'||e.key==='s'||e.key==='S') dy=1;
  else if(e.key==='ArrowLeft'||e.key==='a'||e.key==='A') dx=-1;
  else if(e.key==='ArrowRight'||e.key==='d'||e.key==='D') dx=1;
  movePlayer(dx,dy);
}

function handleSwipe(e){
  if(!touchStart) return;
  const touchEnd = e.changedTouches[0];
  const dx = touchEnd.clientX - touchStart.clientX;
  const dy = touchEnd.clientY - touchStart.clientY;
  if(Math.abs(dx)>Math.abs(dy)){ dx>0?movePlayer(1,0):movePlayer(-1,0); } 
  else { dy>0?movePlayer(0,1):movePlayer(0,-1); }
  touchStart = null;
}

// --- Particle Effect ---
function spawnParticles(x,y,z,color=0xffff00){
  const geom = new THREE.BufferGeometry();
  const vertices = [];
  const count = 30;
  for(let i=0;i<count;i++){
    vertices.push(x, y, z);
  }
  geom.setAttribute('position', new THREE.Float32BufferAttribute(vertices,3));
  const mat = new THREE.PointsMaterial({color, size:0.3});
  const points = new THREE.Points(geom,mat);
  scene.add(points);
  particlesGroup.push({points, life:30});
}

// --- Move Player ---
function movePlayer(dx,dy){
  const nx = playerPos.x+dx, ny = playerPos.y+dy;
  if(nx<0||ny<0||nx>=gridSize||ny>=gridSize) return;
  for(let w of maze) if(Math.round(w.position.x/cellSize)-0.5===nx && Math.round(w.position.z/cellSize)-0.5===ny) return;

  playerPos.x=nx; playerPos.y=ny;
  gsap.to(playerMesh.position,{duration:0.2, x:nx*cellSize+cellSize/2, z=ny*cellSize+cellSize/2});
  gsap.to(scene.rotation,{duration:0.15, x:dy*0.05, z:-dx*0.05, yoyo:true, repeat:1});

  // Stars collision
  for(let i=stars.length-1;i>=0;i--){
    if(stars[i].x===nx && stars[i].y===ny){
      spawnParticles(playerMesh.position.x,playerMesh.position.y,playerMesh.position.z,0xffff00);
      scene.remove(stars[i].mesh); stars.splice(i,1);
      score+=10; playSound('starSound'); updateStatus();
    }
  }

  // Traps collision
  for(let t of traps){ if(t.x===nx && t.y===ny){ playSound('trapSound'); timer=Math.max(1,timer-5); updateStatus(); } }

  // Exit collision
  if(nx===gridSize-1 && ny===gridSize-1){
    spawnParticles(exitMesh.position.x,exitMesh.position.y,exitMesh.position.z,0x00ff00);
    playSound('exitSound');
    level++; gridSize=Math.min(gridSize+1,10); playerPos={x:0,y:0};
    createMaze(); createPlayer(); createExit(); updateStatus();
  }
}

// --- UI / Timer ---
function updateStatus(){
  document.getElementById('status').textContent=
    `Level: ${level} | Score: ${score} | Time: ${timer} | Highscore: ${highscore}`;
  if(score>highscore){ highscore=score; localStorage.setItem('miniMazeHighscore',highscore);}
}

function startTimer(){
  clearInterval(interval);
  interval=setInterval(()=>{
    timer--; if(timer<=0){
      alert('Time up!');
      if(score>highscore){ highscore=score; localStorage.setItem('miniMazeHighscore',highscore); alert('New Highscore: '+highscore);}
      level=1; gridSize=5; score=0; timer=30; createMaze(); createPlayer(); createExit(); updateStatus();
    }
    updateStatus();
  },1000);
}

// --- Animate ---
function animate(){
  requestAnimationFrame(animate);

  // Stars rotation
  for(let s of stars) s.mesh.rotation.y+=0.02;
  // Glow traps
  for(let t of traps) t.mesh.material.emissiveIntensity=0.3+0.2*Math.sin(Date.now()*0.01);

  // Camera follow
  gsap.to(camera.position,{duration:0.2, x:playerMesh.position.x + gridSize, z:playerMesh.position.z + gridSize});
  camera.lookAt(playerMesh.position);

  // Animate particles
  for(let i=particlesGroup.length-1;i>=0;i--){
    const p = particlesGroup[i]; const positions = p.points.geometry.attributes.position.array;
    for(let j=0;j<positions.length;j+=3){
      positions[j] += (Math.random()-0.5)*0.2;
      positions[j+1] += Math.random()*0.2;
      positions[j+2] += (Math.random()-0.5)*0.2;
    }
    p.points.geometry.attributes.position.needsUpdate=true;
    p.life--;
    if(p.life<=0){ scene.remove(p.points); particlesGroup.splice(i,1); }
  }

  renderer.render(scene,camera);
}
</script>
</body>
</html>
